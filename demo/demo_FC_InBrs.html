<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="author" content="Chang">

    <style>
        #netDef2 {
            position: absolute;
            left: 270px;
            top: 8px;
        }

        #netDef3 {
            position: absolute;
            left: 530px;
            top: 8px;
        }

        #netDef4 {
            position: absolute;
            left: 790px;
            top: 8px;
        }

        #netDef5 {
            position: absolute;
            left: 1050px;
            top: 8px;
        }
    </style>

    <style>
        .axis .domain {
            display: none;
        }
    </style>

    <script src="jquery-1.8.3.min.js"></script>
    <script src="../build/vis.js"></script>
    <script src="../build/util.js"></script>
    <script src="../build/convnet.js"></script>
    <script src="../demo/mnist_labels.js"></script>
    <script src="https://d3js.org/d3.v4.js"></script>



    <script>
        var netIndex = 1;
        var layerIndex = new Array(5);//cuz there are up to 5 child/hatched nets
        for (var i = 0; i < 5; i++) { layerIndex[i] = 10 + 10 * i + 2; }
        var neuronIndex = 30;
        var layerLog = new Array(5);//cuz there are up to 5 child/hatched nets
        for (var i = 0; i < 5; i++) { layerLog[i] = 2; }
        function addOne(layerID) {
            var temp = layerID - 1;
            var num = document.getElementById(temp);
            num.value = parseInt(num.value) + 1;
        }
        function minusOne(layerID) {
            var temp = layerID - 1;
            var num = document.getElementById(temp);
            if (num.value > 0) {
                num.value = parseInt(num.value) - 1;
            }
        }

        var layer_defs = new Array();
        var net = new Array();
        var hatched_defs = new Array();
        var hatchedNet = new Array();
        var trainer = new Array();
        var t = new Array();
        var legend = new Array();
        var startHatching = false;
        var Fwd = new Array();
        var STEP = 0;
        var Baseline_EA = 0;
        var MN_EA = 0;
        var trainStart_CN = new Array(5);
        var trainEnd_CN = new Array(5);
        var training_CN = new Array(5);
        var trainStart_MN = 0;
        var trainEnd_MN = 0;
        var training_MN = 0;
        var trainStart_HN = new Array(5);
        var trainEnd_HN = new Array(5);
        var training_HN = new Array(5);
        var Accuracy30_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy30_Time[i] = 0;
        }
        var Accuracy50_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy50_Time[i] = 0;
        }
        var Accuracy70_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy70_Time[i] = 0;
        }
        var Accuracy90_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy90_Time[i] = 0;
        }
        var AccuracyCvg_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            AccuracyCvg_Time[i] = 0;
        }
        //for(var i = 0; i < 5 ; i++) {trainStart_HN[i] = new Date().getTime();}
        var MN_convergence = false;
        var CN_convergence = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_convergence[i] = false;
        }
        var HN_convergence = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_convergence[i] = false;
        }
        var CN_convergeACC = new Array(5);
        for(var i=0;i<5;i++){
            CN_convergeACC[i]=0;
        }
        var MN_convergeACC = 0;
        var HN_convergeACC = new Array(5);
        for(var i=0;i<5;i++){
            HN_convergeACC[i]=0;
        }

        //initialize MN
        var mother_defs, motherNet;
        mother_defs = [];
        mother_defs.push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });//the mother net needs an input layer by default



        //there are already three children networks by default
        t[0] = "layer_defs[0] = [];\n\
        layer_defs[0].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'softmax', num_classes:10});\n\
        \n\
        net[0] = new convnetjs.Net();\n\
        net[0].makeLayers(layer_defs[0]);\n\
        \n\
        trainer[0] = new convnetjs.Trainer(net[0], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        t[1] = "layer_defs[1] = [];\n\
        layer_defs[1].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'softmax', num_classes:10});\n\
        \n\
        net[1] = new convnetjs.Net();\n\
        net[1].makeLayers(layer_defs[1]);\n\
        \n\
        trainer[1] = new convnetjs.Trainer(net[1], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        t[2] = "layer_defs[2] = [];\n\
        layer_defs[2].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'softmax', num_classes:10});\n\
        \n\
        net[2] = new convnetjs.Net();\n\
        net[2].makeLayers(layer_defs[2]);\n\
        \n\
        trainer[2] = new convnetjs.Trainer(net[2], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        var step_num = 0;
        var maxmin = cnnutil.maxmin;
        var f2t = cnnutil.f2t;
        // ------------------------
        // BEGIN MNIST SPECIFIC STUFF
        // ------------------------
        var classes_txt = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

        var use_validation_data = true;

        var num_batches = 21; // 20 training batches, 1 test batch
        var num_bg_batches = 21;
        var test_batch = 20;
        var data_img_elts = new Array(num_batches);
        var bg_data_img_elts = new Array(num_bg_batches);
        var img_data = new Array(num_batches);
        var bg_img_data = new Array(num_bg_batches);
        var loaded = new Array(num_batches);
        var loaded_train_batches = [];

        var sample_training_instance = function () {
            // find an unloaded batch
            var bi = Math.floor(Math.random() * loaded_train_batches.length);
            var b = loaded_train_batches[bi];
            var k = Math.floor(Math.random() * 3000); // sample within the batch
            var n = b * 3000 + k;

            // load more batches over time
            if (step_num % 3000 === 0 && step_num > 0) {
                for (var i = 0; i < num_batches; i++) {
                    if (!loaded[i]) {
                        load_data_batch(i);
                        break;
                    }
                }
            }

            // fetch the appropriate row of the training image and reshape into a Vol
            var p = img_data[b].data;
            var x = new convnetjs.Vol(28, 28, 1, 0.0);
            var W = 28 * 28;
            var j = 0;
            for (var i = 0; i < W; i++) {
                var ix = ((W * k) + i) * 4;
                x.w[i] = p[ix] / 255.0;
            }

            var isval = use_validation_data && n % 10 === 0 ? true : false;
            return { x: x, label: labels[n], isval: isval };
        }

        var sample_bg_training_instance = function () {
            var bg = 0;
            var bi = Math.floor(Math.random() * loaded_train_batches.length);
            var b = loaded_train_batches[bi];
            var k = Math.floor(Math.random() * 3000);
            var n = b * 3000 + k;
            // load more batches over time
            if (step_num % 5000 === 0 && step_num > 0) {
                bg = Math.floor(Math.random() * num_batches);
                load_bg_data_batch(bg);
            }

            // fetch the appropriate row of the training image and reshape into a Vol
            var p = bg_img_data[bg].data;
            var x = new convnetjs.Vol(28, 28, 1, 0.0);
            var W = 28 * 28;
            var j = 0;
            for (var i = 0; i < W; i++) {
                var ix = ((W * k) + i) * 4;
                x.w[i] = p[ix] / 255.0;
            }

            var isval = use_validation_data && n % 10 === 0 ? true : false;
            return { x: x, label: labels[n], isval: isval };
        }

        // // sample a random testing instance
        // var sample_test_instance = function () {

        //     var b = test_batch;
        //     var k = Math.floor(Math.random() * 1000);
        //     var n = b * 1000 + k;

        //     var p = img_data[b].data;
        //     var x = new convnetjs.Vol(32, 32, 3, 0.0);
        //     var W = 32 * 32;
        //     var j = 0;
        //     for (var dc = 0; dc < 3; dc++) {
        //         var i = 0;
        //         for (var xc = 0; xc < 32; xc++) {
        //             for (var yc = 0; yc < 32; yc++) {
        //                 var ix = ((W * k) + i) * 4 + dc;
        //                 x.set(yc, xc, dc, p[ix] / 255.0 - 0.5);
        //                 i++;
        //             }
        //         }
        //     }

        //     // distort position and maybe flip
        //     var xs = [];
        //     //xs.push(x, 32, 0, 0, false); // push an un-augmented copy
        //     for (var k = 0; k < 6; k++) {
        //         var dx = Math.floor(Math.random() * 5 - 2);
        //         var dy = Math.floor(Math.random() * 5 - 2);
        //         xs.push(convnetjs.augment(x, 32, dx, dy, k > 2));
        //     }

        //     // return multiple augmentations, and we will average the network over them
        //     // to increase performance
        //     return { x: xs, label: labels[n] };
        // }

        // int main
        $(window).load(function () {

            for (var i = 0; i < t.length; i++) {
                $("#newnet" + i).val(t[i]);
                eval($("#newnet" + i).val());
                hatched_defs[i] = [];
                hatched_defs[i] = layer_defs[i];
                hatchedNet[i] = new convnetjs.Net();
                hatchedNet[i].makeLayers(hatched_defs[i]);
                trainer[i + 6] = new convnetjs.SGDTrainer(hatchedNet[i], { method: 'adadelta', batch_size: 20, l2_decay: 0.001 });
                legend[i] = 'childNet ' + i;
                //legend[t.length + 1 + i] = 'hatchedNet ' + i;
            }
            legend[t.length] = 'motherNet';

            // for(var i=0;legend[i];i++){
            //     console.log(legend[i]);
            // }


            //we built mother network here based on layer definitions of each child network
            //we look at all the children networks at all convolutional layers (so we skip Input, pooling and softmax layers)
            //, and add the one with fewest filters into the mother network.
            //find the longest childnet who have the most layers
            var longestLength = 0;
            for (var n = 0; n < layer_defs.length; n++) {
                if (longestLength < layer_defs[n].length) {
                    longestLength = layer_defs[n].length;
                }
            }
            //loop for all positions but skip the input layer and softmax layer.
            for (var i = 1; i < longestLength - 1; i++) {
                var temp_neuronNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'fc' && layer_defs[j][i].num_neurons < temp_neuronNum && layer_defs[j][i].num_neurons > 0) {
                        temp_neuronNum = layer_defs[j][i].num_neurons;
                    }
                }
                mother_defs.push({ type: 'fc', num_neurons: temp_neuronNum, activation: 'relu' });
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it
            trainer[5] = new convnetjs.Trainer(motherNet, { method: 'adadelta', batch_size: 10, l2_decay: 0.001 });

            //for now, we show the motherNet by simply print each layer
            var m2t = document.getElementById("MotherNet_vis");
            m2t.innerHTML = '';
            for (var i = 0; mother_defs[i]; i++) {
                if (i == 0) {
                    var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'fc') {
                    var mt = 'Fully connected layer:' + ' num_neurons:' + mother_defs[i].num_neurons + ' activation:' + mother_defs[i].activation;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (i == mother_defs.length - 1) {
                    var mt = 'Softmax layer: number of classes: 10';//since we are using MNIST
                    m2t.appendChild(document.createTextNode(mt));
                }
            }


            for (var k = 0; k < loaded.length; k++) { loaded[k] = false; }

            load_data_batch(0); // async load train set batch 0 (6 total train batches)
            load_data_batch(test_batch); // async load test set (batch 6)
            load_bg_data_batch(0);
            load_bg_data_batch(test_batch);
            for (var i = 0; i < 5; i++) { trainStart_CN[i] = new Date().getTime(); }
            trainStart_MN = new Date().getTime();
            start_fun();
            //bg_start_fun();




        });

        var start_fun = function () {
            if (loaded[0] && loaded[test_batch]) {
                console.log('starting!');
                setInterval(load_and_step, 0);
            }
            else { setTimeout(start_fun, 200); } // keep checking
            //setInterval(widenNets(motherNet, hatchedNet), 1000); //use Mother Network to update hatched networks every 1 sec
        }
        /*
                //hatched part
                var bg_start_fun = function () {
                    if (loaded[test_batch]) {
                        console.log('BG starting!');
                        setInterval(bg_load_and_step, 100);
                    }
                    else { setTimeout(bg_start_fun, 200); }
                }
        */
        var load_data_batch = function (batch_num) {
            // Load the dataset with JS in background
            data_img_elts[batch_num] = new Image();
            var data_img_elt = data_img_elts[batch_num];
            data_img_elt.onload = function () {
                var data_canvas = document.createElement('canvas');
                data_canvas.width = data_img_elt.width;
                data_canvas.height = data_img_elt.height;
                var data_ctx = data_canvas.getContext("2d");
                data_ctx.drawImage(data_img_elt, 0, 0); // copy it over... bit wasteful :(
                img_data[batch_num] = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
                loaded[batch_num] = true;
                if (batch_num < 20) { loaded_train_batches.push(batch_num); }
                console.log('finished loading data batch ' + batch_num);
            };
            data_img_elt.src = "mnist_batch_" + batch_num + ".png";
        }

        var load_bg_data_batch = function (batch_num) {
            // Load the dataset with JS in background
            bg_data_img_elts[batch_num] = new Image();
            var bg_data_img_elt = bg_data_img_elts[batch_num];
            bg_data_img_elt.onload = function () {
                var bg_data_canvas = document.createElement('canvas');
                bg_data_canvas.width = bg_data_img_elt.width;
                bg_data_canvas.height = bg_data_img_elt.height;
                var bg_data_ctx = bg_data_canvas.getContext("2d");
                bg_data_ctx.drawImage(bg_data_img_elt, 0, 0); // copy it over... bit wasteful :(
                bg_img_data[batch_num] = bg_data_ctx.getImageData(0, 0, bg_data_canvas.width, bg_data_canvas.height);
                console.log('finished loading bagging data batch ' + batch_num);
            };
            bg_data_img_elt.src = "mnist_batch_" + batch_num + ".png";
        }


        // ------------------------
        // END MNIST SPECIFIC STUFF
        // ------------------------

        // loads a training image and trains on it with the Children Networks and Mother Network
        var paused = false;
        var embed_samples = [];
        var embed_imgs = [];
        var load_and_step = function () {
            if (paused) return;

            // if (embed_samples.length === 0) { // happens once
            //     for (var k = 0; k < 200; k++) {
            //         var s = sample_training_instance();
            //         embed_samples.push(s);
            //         // render x and save it too
            //         var I = render_act(s.x);
            //         embed_imgs.push(I);
            //     }
            // }
            var sample = sample_training_instance();
            step(sample); // process this image
        }
        // the hatchedNet part
        var embed_bg_samples = [];
        var embed_bg_imgs = [];
        var bg_load_and_step = function () {
            if (paused) return;

            if (embed_bg_samples.length === 0) {
                for (var k = 0; k < 200; k++) {
                    var s = sample_bg_training_instance();
                    embed_bg_samples.push(s);
                    var I = render_act(s.x);
                    embed_bg_imgs.push(I);
                }
            }
            var sample = sample_bg_training_instance();
            bg_step(sample);
        }

        //var lossGraph = new cnnvis.MultiGraph(legend, );
        var xLossWindow = new Array();
        var wLossWindow = new Array();
        var trainAccWindow = new Array();
        var valAccWindow = new Array();
        var testAccWindow = new Array();
        var MNtempAcc = 0;//log the temporary accuracy of MN every 500 steps
        for (var i = 0; i < 5; i++) {
            xLossWindow[i] = new cnnutil.Window(100);
            wLossWindow[i] = new cnnutil.Window(100);
            trainAccWindow[i] = new cnnutil.Window(100);
            valAccWindow[i] = new cnnutil.Window(100);
            testAccWindow[i] = new cnnutil.Window(100);
        }
        //the MN part
        xLossWindow[5] = new cnnutil.Window(100);
        wLossWindow[5] = new cnnutil.Window(100);
        trainAccWindow[5] = new cnnutil.Window(100);
        valAccWindow[5] = new cnnutil.Window(100);
        testAccWindow[5] = new cnnutil.Window(100);
        //temp hatchedNet part
        for (var i = 6; i < 10; i++) {
            xLossWindow[i] = new cnnutil.Window(100);
            wLossWindow[i] = new cnnutil.Window(100);
            trainAccWindow[i] = new cnnutil.Window(100);
            valAccWindow[i] = new cnnutil.Window(100);
            testAccWindow[i] = new cnnutil.Window(100);
        }
        //the HatchedNet part
        var bg_xLossWindow = new Array();
        var bg_wLossWindow = new Array();
        var bg_trainAccWindow = new Array();
        var bg_valAccWindow = new Array();
        var bg_testAccWindow = new Array();
        for (var i = 0; i < 5; i++) {
            bg_xLossWindow[i] = new cnnutil.Window(100);
            bg_wLossWindow[i] = new cnnutil.Window(100);
            bg_trainAccWindow[i] = new cnnutil.Window(100);
            bg_valAccWindow[i] = new cnnutil.Window(100);
            bg_testAccWindow[i] = new cnnutil.Window(100);
        }












        var step = function (sample) {

            if (step_num % 500 === 0 && step_num > 0) {
                //     console.log(motherNet.layers[3].filters);
                // for (var i = 0; hatchedNet[i]; i++) {
                //     console.log(hatchedNet[i].layers[3].filters);
                //     console.log('');
                // }
                widenNets(motherNet, hatchedNet);
                //     var Test = sample_training_instance().x;
                //     // for (var i = 0; net[i]; i++) {
                //     //     console.log(net[i].getPrediction());
                //     // }
                //     console.log(motherNet.forward(Test) === hatchedNet[1].forward(Test));
                //     console.log(motherNet.layers[3].filters);
                // for (var i = 0; hatchedNet[i]; i++) {
                //     console.log(hatchedNet[i].layers[3].filters);
                // }
                // console.log('');
                //     console.log('');
            }





            var x = sample.x;
            var y = sample.label;
            var stats = new Array();
            var lossx = new Array();
            var lossw = new Array();


            if (sample.isval) {
                var yhat = new Array();
                var val_acc = new Array();
                // use x to build our estimate of validation error
                for (var i = 0; net[i]; i++) {
                    net[i].forward(x);
                    yhat[i] = net[i].getPrediction();
                    val_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                    valAccWindow[i].add(val_acc[i]);
                }
                //the MN part
                motherNet.forward(x);
                yhat[5] = motherNet.getPrediction();
                val_acc[5] = yhat[5] === y ? 1.0 : 0.0;
                valAccWindow[5].add(val_acc[5]);
                //temp hatchedNet part
                for (var i = 0; hatchedNet[i]; i++) {
                    hatchedNet[i].forward(x);
                    yhat[i + 6] = hatchedNet[i].getPrediction();
                    val_acc[i + 6] = yhat[i + 6] === y ? 1.0 : 0.0;
                    valAccWindow[i + 6].add(val_acc[i + 6]);
                }
                return;
            }

            //Now, we train MN method and baseline method at the same time, but we train networks in both of these methods sequentially
            // train on it with networks
            for (var i = 0; net[i]; i++) {
                if (i === 0 && CN_convergence[0] === false) {
                    stats[i] = trainer[i].train(x, y);
                    lossx[i] = stats[i].cost_loss;
                    lossw[i] = stats[i].l2_decay_loss;
                    xLossWindow[i].add(lossx[i]);
                    wLossWindow[i].add(lossw[i]);
                }
                else if (i > 0 && CN_convergence[i - 1] === true && CN_convergence[i] === false) {
                    stats[i] = trainer[i].train(x, y);
                    lossx[i] = stats[i].cost_loss;
                    lossw[i] = stats[i].l2_decay_loss;
                    xLossWindow[i].add(lossx[i]);
                    wLossWindow[i].add(lossw[i]);
                }
            }
            //the MN part
            if (MN_convergence === false) {
                stats[5] = trainer[5].train(x, y);
                lossx[5] = stats[5].cost_loss;
                lossw[5] = stats[5].l2_decay_loss;
                xLossWindow[5].add(lossx[5]);
                wLossWindow[5].add(lossw[5]);
            }
            //temp hatchedNet part
            else if (MN_convergence === true) {
                for (var i = 0; hatchedNet[i]; i++) {
                    if (i === 0 && HN_convergence[0] === false) {
                        stats[i + 6] = trainer[i + 6].train(x, y);
                        lossx[i + 6] = stats[i + 6].cost_loss;
                        lossw[i + 6] = stats[i + 6].l2_decay_loss;
                        xLossWindow[i + 6].add(lossx[i + 6]);
                        wLossWindow[i + 6].add(lossw[i + 6]);
                    }
                    else if (i > 0 && HN_convergence[i - 1] === true && HN_convergence[i] === false) {
                        stats[i + 6] = trainer[i + 6].train(x, y);
                        lossx[i + 6] = stats[i + 6].cost_loss;
                        lossw[i + 6] = stats[i + 6].l2_decay_loss;
                        xLossWindow[i + 6].add(lossx[i + 6]);
                        wLossWindow[i + 6].add(lossw[i + 6]);
                    }
                }
            }


            // keep track of stats such as the average training error and loss
            var yhat = new Array();
            var train_acc = new Array();
            for (var i = 0; net[i]; i++) {
                yhat[i] = net[i].getPrediction();
                train_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                trainAccWindow[i].add(train_acc[i]);
            }
            //the MN part
            yhat[5] = motherNet.getPrediction();
            train_acc[5] = yhat[5] === y ? 1.0 : 0.0;
            trainAccWindow[5].add(train_acc[5]);
            //temp hatchedNet part
            for (var i = 0; hatchedNet[i]; i++) {
                yhat[i + 6] = hatchedNet[i].getPrediction();
                train_acc[i + 6] = yhat[i + 6] === y ? 1.0 : 0.0;
                trainAccWindow[i + 6].add(train_acc[i + 6]);
            }

            /*
                        // visualize training status
                        var train_elt = document.getElementById("trainstats");
                        train_elt.innerHTML = '';
                        for (var i = 0; net[i]; i++) {
                            var T = 'Forward time of network' + i + ' per example: ' + stats[i].fwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Forward time of MotherNetwork per example: ' + stats[5].fwd_time + 'ms';
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Forward time of hatched network' + i + ' per example: ' + stats[i + 6].fwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Backprop time of network' + i + ' per example: ' + stats[i].bwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Backprop time of MotherNetwork per example: ' + stats[5].bwd_time + 'ms';
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Backprop time of hatched network' + i + ' per example: ' + stats[i + 6].bwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Classification loss of network' + i + ' : ' + f2t(xLossWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Classification loss of MotherNetwork: ' + f2t(xLossWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Classification loss of hatched network' + i + ' : ' + f2t(xLossWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'L2 Weight decay loss of network' + i + ' : ' + f2t(wLossWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'L2 Weight decay loss of MotherNetwork: ' + f2t(wLossWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'L2 Weight decay loss of hatched network' + i + ' : ' + f2t(wLossWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Training accuracy of network' + i + ' : ' + f2t(trainAccWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Training accuracy of MotherNetwork: ' + f2t(trainAccWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Training accuracy of hatched network' + i + ' : ' + f2t(trainAccWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Validation accuracy of network' + i + ' : ' + f2t(valAccWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Validation accuracy of MotherNetwork: ' + f2t(valAccWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Validation accuracy of hatched network' + i + ' : ' + f2t(valAccWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Examples seen: ' + step_num;
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
            */

            // // log progress to graph, (full loss)
            // if (step_num % 100 === 0 && step_num >= 200) {
            //     var Y = new Array();
            //     for (var i = 0; i < net.length; i++) {
            //         var xa = xLossWindow[i].get_average();
            //         var xw = wLossWindow[i].get_average();
            //         if (xa >= 0 && xw >= 0) { // if they are -1 it means not enough data was accumulated yet for estimates
            //             Y[i] = xa + xw;
            //         }
            //     }
            //     if (xLossWindow[5].get_average() >= 0 && wLossWindow[5].get_average() >= 0) {
            //         Y.push(xLossWindow[5].get_average() + wLossWindow[5].get_average());
            //     }
            //     // for (var i = 0; i < hatchedNet.length; i++) {
            //     //     Y.push(xLossWindow[i + 6].get_average() + wLossWindow[i + 6].get_average());
            //     // }
            //     lossGraph.add(step_num, Y);
            //     lossGraph.drawSelf(document.getElementById("lossgraph"));


            // }

            // if(isNaN(hatchedNet[1].layers[3].filters[1].w[1])){
            //     console.log(step_num);
            // }

            //compute the ensemble averaging accuracy
            Baseline_EA = 0;
            if (CN_convergence[0] && CN_convergence[1] && CN_convergence[2]) {
                for (var i = 0; net[i]; i++) {
                    Baseline_EA += CN_convergeACC[i];
                    //console.log(Baseline_EA);
                }
                Baseline_EA /= net.length;
            }
            MN_EA = 0;
            if (HN_convergence[0] && HN_convergence[1] && HN_convergence[2]) {
                for (var i = 0; hatchedNet[i]; i++) {
                    MN_EA += HN_convergeACC[i];
                    //console.log(trainAccWindow[i + 6].get_average());
                }
                MN_EA /= hatchedNet.length;
            }

            //compute training time
            //30% acc time
            if (Accuracy30_Time[0] === 0 || Accuracy30_Time[1] === 0 || Accuracy30_Time[2] === 0) {
                for (var n = 0; net[n]; n++) {
                    if (trainAccWindow[n].get_average() > 0.3 && trainAccWindow[n].get_average() < 0.5 && Accuracy30_Time[n] === 0) {

                        trainEnd_CN[n] = new Date().getTime();
                        Accuracy30_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                        //console.log(Accuracy30_Time[n]);
                    }
                }
            }
            if (trainAccWindow[5].get_average() > 0.3 && trainAccWindow[5].get_average() < 0.5 && Accuracy30_Time[5] === 0) {

                trainEnd_MN = new Date().getTime();
                Accuracy30_Time[5] = trainEnd_MN - trainStart_MN;

            }

            //50% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.5 && trainAccWindow[n].get_average() < 0.7 && Accuracy50_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy50_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.5 && trainAccWindow[5].get_average() < 0.7 && Accuracy50_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy50_Time[5] = trainEnd_MN - trainStart_MN;
            }

            //70% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.7 && trainAccWindow[n].get_average() < 0.9 && Accuracy70_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy70_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.7 && trainAccWindow[5].get_average() < 0.9 && Accuracy70_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy70_Time[5] = trainEnd_MN - trainStart_MN;
            }

            //90% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.9 && Accuracy90_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy90_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.9 && Accuracy90_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy90_Time[5] = trainEnd_MN - trainStart_MN;
            }



            //judge the convergence
            for (var i = 0; net[i]; i++) {
                if (trainAccWindow[i].get_average() > 0.9 && CN_convergence[i] === false) {
                    CN_convergence[i] = true;
                    CN_convergeACC[i] = trainAccWindow[i].get_average();
                }
            }
            if (trainAccWindow[5].get_average() > 0.9 && MN_convergence === false) {
                MN_convergence = true;
                MN_convergeACC = trainAccWindow[5].get_average();
            }
            for (var i = 0; hatchedNet[i]; i++) {
                if (trainAccWindow[i + 6].get_average() > 0.9 && HN_convergence[i] === false) {
                    HN_convergence[i] = true;
                    HN_convergeACC[i] = trainAccWindow[i + 6].get_average();
                }
            }



            step_num++;
            STEP = step_num;
        }




        //widening function
        function widenNets(motherNet, hatchedNet) {
            // console.log(motherNet.layers[3].filters);
            // for (var i = 0; hatchedNet[i]; i++) {
            //     console.log(hatchedNet[i].layers[3].filters);
            // }
            //For the original part in MN, just copy them
            for (var l = 1; l < motherNet.layers.length - 3; l++) { //loop by each hidden fc layer in MN
                if (motherNet.layers[l].layer_type === 'fc') {
                    for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //loop by each "filter" in a certain fc layer
                        for (var i = 0; i < motherNet.layers[l].filters[f].w.length; i++) { //loop by each weight in a certain "filter"
                            for (var j = 0; hatchedNet[j]; j++) { //copy the weight to every hatchedNet
                                hatchedNet[j].layers[l].filters[f].w[i] = motherNet.layers[l].filters[f].w[i];
                            }
                        }
                    }
                }
            }

            //For the widened part, use the random select
            for (var h = 0; hatchedNet[h]; h++) { //widen each hatchedNet one by one
                for (var l = 1; l < motherNet.layers.length - 3; l++) { //loop by each fc layer in MN except for the last one
                    if (motherNet.layers[l].layer_type === 'fc') {
                        var rdmSlct = 0;
                        var copyCount = new Array(motherNet.layers[l].filters.length), i = copyCount.length; //count how many times has a filter in a certain layer of MN been copied
                        while (i--) { copyCount[i] = 0; } //initialize them with 0
                        var copyPosition = new Array(motherNet.layers[l].filters.length); //log the position in hatchedNet which copied the a certain filter of MN
                        for (var j = 0; j < copyPosition.length; j++) { //initialize them with 0
                            copyPosition[j] = new Array(hatchedNet[h].layers[l].filters.length - motherNet.layers[l].filters.length);
                            for (var k = 0; k < copyPosition[j].length; k++) {
                                copyPosition[j][k] = 0;
                            }
                        }
                        if (motherNet.layers[l].filters.length < hatchedNet[h].layers[l].filters.length) {
                            for (var f = motherNet.layers[l].filters.length; f < hatchedNet[h].layers[l].filters.length; f++) { //build the widened part in a certain layer
                                //console.log(f);
                                rdmSlct = randomFrom(0, motherNet.layers[l].filters.length); //randomly select a filter in the layer l of MN
                                //console.log(copyPosition[rdmSlct][f - motherNet.layers[l].filters.length]+','+rdmSlct+','+(f - motherNet.layers[l].filters.length));
                                hatchedNet[h].layers[l].filters[f] = hatchedNet[h].layers[l].filters[rdmSlct]; //copy it to the filter f in the widened part of layer l in hatchedNet
                                copyCount[rdmSlct]++; //log the copyCount
                                copyPosition[rdmSlct][f - motherNet.layers[l].filters.length] = 1; //log the copy position
                            }
                        }

                        if (motherNet.layers[l + 2].layer_type === 'fc') {
                            for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //for the copied filter f in layer l, we divide the counter part, weight f in every filter of layer l+1 of MN original part, by copyCount+1
                                if (copyCount[f] > 0) {
                                    for (var nxt = 0; nxt < motherNet.layers[l + 2].filters.length; nxt++) { //deal with the next layer
                                        hatchedNet[h].layers[l + 2].filters[nxt].w[f] /= (copyCount[f] + 1);
                                        for (var i = motherNet.layers[l].filters.length; i < hatchedNet[h].layers[l].filters.length; i++) { //for the filters in widened part who copied the filter f in MN, we use the updated filter in MN original part to update them
                                            if (copyPosition[f][i - motherNet.layers[l].filters.length] === 1) {
                                                hatchedNet[h].layers[l + 2].filters[nxt].w[i] = hatchedNet[h].layers[l + 2].filters[nxt].w[f];
                                                if (step_num > 700 && step_num < 900) { console.log(hatchedNet[h].layers[l + 2].filters[nxt].w[i]); }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }



        //build the hatched networks
        //generate a random integer
        function randomFrom(lowerValue, upperValue) {
            return Math.floor(Math.random() * (upperValue - lowerValue) + lowerValue);
        }
        //Hatch function
        function Hatch(motherNet, hatchedNet) {
            //For the original part in MN, just copy them
            for (var l = 0; l < motherNet.layers.length - 3; l++) { //loop by each hidden fc layer in MN
                if (motherNet.layers[l].layer_type === 'fc') {
                    console.log(l);
                    for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //loop by each "filter" in a certain fc layer
                        for (var i = 0; i < motherNet.layers[l].filters[f].w.length; i++) { //loop by each weight in a certain "filter"
                            for (var j = 0; hatchedNet[j]; j++) { //copy the weight to every hatchedNet
                                hatchedNet[j].layers[l].filters[f].w[i] = motherNet.layers[l].filters[f].w[i];
                            }
                        }
                    }
                }
                else {
                    console.log(motherNet.layers[l].layer_type);
                }
            }
            //deepen hatchedNets now
            var Len = motherNet.layers[motherNet.layers.length - 4].filters.length;//the size of the last fc layer in MN. (every fc layer is followed by an activation layer and another fc layer is inserted before softmax without activation(this fc layer should be ignored))
            for (var h = 0; hatchedNet[h]; h++) {//loop by every hatchedNet
                if (motherNet.layers.length < hatchedNet[h].layers.length) {//find a hatchedNet needed to be deepen
                    for (var l = motherNet.layers.length - 2; l < hatchedNet[h].layers.length - 3; l++) {//loop by every deepened hidden layer in HN
                        if (hatchedNet[h].layers[l].layer_type === 'fc') {
                            for (var f = 0; f < hatchedNet[h].layers[l].filters.length; f++) {//loop by every "filter" in deepened layer l in HN
                                for (var p = 0; p < hatchedNet[h].layers[l].filters[f].length; p++) {//loop by every parameter in filter f
                                    hatchedNet[h].layers[l].filters[f].w[p] = 0;
                                }
                                if (f < Len) {
                                    hatchedNet[h].layers[l].filters[f].w[f] = 1;
                                }
                            }
                        }
                    }
                    //preserve the output and pad 0
                    for (var F = 0; F < hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters.length; F++) {
                        for (var P = 0; P < hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].length; P++) {
                            if (P < motherNet.layers[motherNet.layers.length - 2].filters[F].length) {
                                hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].w[P] = motherNet.layers[motherNet.layers.length - 2].filters[F].w[P];
                            }
                            hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].w[P] = 0;
                        }
                    }
                }
            }

            //For the widened part, use the random select
            for (var h = 0; hatchedNet[h]; h++) { //widen each hatchedNet one by one
                var L = 0;
                for (var l = 1; l < hatchedNet[h].layers.length - 3; l++) { //loop by each fc layer in HN except for the last one
                    if (l <= motherNet.layers.length - 4) {
                        L = l;
                    }
                    else { //L represents the last hidden layer in MN if l has been bigger than MN's length(without softmax and the inserted fc)
                        L = motherNet.layers.length - 4;
                    }
                    if (hatchedNet[h].layers[l].layer_type === 'fc') {
                        var rdmSlct = 0;
                        var copyCount = new Array(motherNet.layers[L].filters.length), i = copyCount.length; //count how many times has a filter in a certain layer of MN part been copied
                        while (i--) { copyCount[i] = 0; } //initialize them with 0
                        var copyPosition = new Array(motherNet.layers[L].filters.length); //log the position in hatchedNet which copied the a certain filter of MN
                        for (var j = 0; j < copyPosition.length; j++) { //initialize them with 0
                            copyPosition[j] = new Array(hatchedNet[h].layers[l].filters.length - motherNet.layers[l].filters.length);
                            for (var k = 0; k < copyPosition[j].length; k++) {
                                copyPosition[j][k] = 0;
                            }
                        }
                        for (var f = motherNet.layers[L].filters.length; f < hatchedNet[h].layers[l].filters.length; f++) { //build the widened part in a certain layer
                            rdmSlct = randomFrom(0, motherNet.layers[L].filters.length); //randomly select a filter in the layer l of MN
                            //console.log(copyPosition[rdmSlct][f - motherNet.layers[l].filters.length]+','+rdmSlct+','+(f - motherNet.layers[l].filters.length));
                            hatchedNet[h].layers[l].filters[f] = hatchedNet[h].layers[l].filters[rdmSlct]; //copy it to the filter f in the widened part of layer l in hatchedNet
                            copyCount[rdmSlct]++; //log the copyCount
                            copyPosition[rdmSlct][f - motherNet.layers[L].filters.length] = 1; //log the copy position
                        }
                        if (hatchedNet[h].layers[l + 2].layer_type === 'fc') {
                            for (var nxt = 0; nxt < motherNet.layers[l + 2].filters.length; nxt++) { //deal with the next layer
                                for (var f = 0; f < motherNet.layers[L].filters.length; f++) { //for the copied filter f in layer l, we divide the counter part, weight f in every filter of layer l+1 of MN original part, by copyCount+1
                                    if (copyCount[f] > 0) {
                                        hatchedNet[h].layers[l + 2].filters[nxt].w[f] /= (copyCount[f] + 1);
                                        for (var i = motherNet.layers[L].filters.length; i < hatchedNet[h].layers[l].filters.length; i++) { //for the filters in widened part who copied the filter f in MN, we use the updated filter in MN original part to update them
                                            if (copyPosition[f][i - motherNet.layers[L].filters.length] === 1) {
                                                hatchedNet[h].layers[l + 2].filters[i] = hatchedNet[h].layers[l + 2].filters[nxt];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        var reset_all = function () {
            // reinit trainer
            trainer = new Array();
            for (var i = 0; net[i]; i++) {
                trainer[i] = new convnetjs.SGDTrainer(net[i], { method: 'adadelta', batch_size: 4, l2_decay: 0.0001 });
            }

            // reinit windows that keep track of val/train accuracies
            for (var i = 0; $("#newnet" + i).val(); i++) {
                xLossWindow[i].reset();
                wLossWindow[i].reset();
                trainAccWindow[i].reset();
                valAccWindow[i].reset();
                testAccWindow[i].reset();
            }

            step_num = 0;


        }

        var change_net = function () {
            layer_defs = [];
            net = [];
            for (var i = 0; $("#newnet" + i).val(); i++) {
                eval($("#newnet" + i).val());

            }
            reset_all();


            //I'm lazy now, so just paste the code above :(
            var longestLength = 0;
            for (var n = 0; n < layer_defs.length; n++) {
                if (longestLength < layer_defs[n].length) {
                    longestLength = layer_defs[n].length;
                }
            }
            //loop for all positions but skip the input layer and softmax layer.
            for (var i = 1; i < longestLength - 1; i++) {
                var temp_neuronNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'fc' && layer_defs[j][i].num_neurons < temp_neuronNum && layer_defs[j][i].num_neurons > 0) {
                        temp_neuronNum = layer_defs[j][i].num_neurons;
                    }
                }
                mother_defs.push({ type: 'fc', num_neurons: temp_neuronNum, activation: 'tanh' });
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it

            //for now, we show the motherNet by simply print each layer
            var m2t = document.getElementById("MotherNet_vis");
            m2t.innerHTML = '';
            for (var i = 0; mother_defs[i]; i++) {
                if (i == 0) {
                    var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'fc') {
                    var mt = 'Fully connected layer:' + ' num_neurons:' + mother_defs[i].num_neurons + ' activation:' + mother_defs[i].activation;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (i == mother_defs.length - 1) {
                    var mt = 'Softmax layer: number of classes: 10';//since we are using MNIST
                    m2t.appendChild(document.createTextNode(mt));
                }
            }


        }

        function htmlDecode(input) {
            var doc = new DOMParser().parseFromString(input, "text/html");
            return doc.documentElement.textContent;
        }

        function newLayer(networkIndex) {
            var lyPos = document.getElementById("netDef" + networkIndex);
            var newLayerHtml = 'layer' + layerLog[networkIndex - 1]++ + ' has &lt;input type=&quot;button&quot; value=&quot;-&quot; onclick=&quot;minusOne(' + netIndex + layerLog[netIndex - 1] + ')&quot;> &lt;input type=text id=' + layerIndex[netIndex - 1]++ + ' value=' + neuronIndex + ' style=&quot;width:30px;&quot;> &lt;input type=&quot;button&quot; value=&quot;+&quot; onclick=&quot;addOne(' + netIndex + layerLog[netIndex - 1] + ')&quot;> neurons &lt;script>layerLog++;console.log(layerLog);&lt;/script>&lt;br/>';
            console.log(htmlDecode(newLayerHtml));
            lyPos.insertAdjacentHTML('afterbegin', htmlDecode(newLayerHtml));
        }

        function newNetwork() {
            netIndex++;
            var ntPos = document.getElementById("netDef" + netIndex);
            var newNetworkHtml = 'layer1 has &lt;input type="button" value="-" onclick="minusOne(' + netIndex + 2 + ')" > &lt;input type="text" id=' + netIndex + 1 + ' value=30 style="width:30px;" > &lt;input type="button" value="+" onclick="addOne(' + netIndex + 2 + ')"> neurons&lt;br/> &lt;input type=button onclick="newLayer(' + netIndex + ')" value=Add_layer>&lt;br/>childNet' + netIndex + '&lt;br/>';
            console.log(htmlDecode(newNetworkHtml));
            ntPos.insertAdjacentHTML('afterbegin', htmlDecode(newNetworkHtml));
        }



    </script>


</head>




<body>

    <div id="netDef1">
        layer1 has
        <input type="button" value="-" onclick="minusOne(12)" />
        <input type="text" id=11 value=30 style="width:30px;" />
        <input type="button" value="+" onclick="addOne(12)" /> neurons
        <br/>
        <input type=button onclick="newLayer(1)" value=Add_layer>
        <br/> childNet1
    </div>
    <div id="netDef2"></div>
    <div id="netDef3"></div>
    <div id="netDef4"></div>
    <div id="netDef5"></div>


    <br/>
    <input type=button onclick="newNetwork()" value=Add_networks>


    <div id="wrap">

        <!-- <div>
            <h1>Loss:</h1>
            <br>
            <canvas id="lossgraph" style="width:800px;height:400px;">
            </canvas>
            <br />
        </div> -->

        <div id="container1" style="height: 500px; width:800px; margin:0 auto;"></div>
        <br/>
        <div id="container4" style="height: 500px; width:1100px; margin:0 auto;"></div>
        <br/>
        <div id="container3" style="height: 500px; width:1100px; margin:0 auto;"></div>
        <br/>
        <div id="container2" style="height: 500px; width:1100px; margin:0 auto;"></div>
        <br/>




        <h1>Train Stats</h1>
        <div id="trainstats"></div>


        <h1>Instantiate Networks and Trainers</h1>
        <div>
            <!--for now, we allow a user to specify up to 5 children networks-->
            <textarea id="newnet0" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet1" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet2" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet3" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet4" style="width:70%; height:200px;"></textarea>
            <br />
            <input id="buttonnn" type="submit" value="change network" onclick="change_net();" style="width:200px;height:30px;" />
        </div>

        <div>
            <h1>Generated MotherNet</h1>
            <div id="MotherNet_vis"></div>
        </div>

    </div>

</body>




<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts.min.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-gl/echarts-gl.min.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-stat/ecStat.min.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"></script>
<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=ZUONbpqGBsYGXNIYHicvbAbM"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"></script>
<script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/simplex.js"></script>
<script src="http://echarts.baidu.com/build/dist/echarts.js"></script>
<script type="text/javascript">


    require.config({
        paths: {
            'echarts': 'http://echarts.baidu.com/build/dist',

        }
    });

    require(['echarts'], DrawCharts);

    function chart1(ec) {
        var TimeCompare = echarts.init(document.getElementById("container2"));
        var app = {};
        option1 = null;
        app.title = '';

        option1 = {
            title: {
                text: 'Training Time',
                subtext: ''
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: {            // 
                    type: 'shadow'        // 'line' | 'shadow'
                }
            },
            legend: {
                data: ['MN', 'HN1', 'HN2', 'HN3', 'CN1', 'CN2', 'CN3']
            },
            grid: {
                left: '3%',
                right: '4%',
                bottom: '3%',
                containLabel: true
            },
            xAxis: [
                {
                    type: 'category',
                    data: ['0.3 Accuracy', '0.5 Accuracy', '0.7 Accuracy', '0.9 Accuracy', 'Converge']
                }
            ],
            yAxis: [
                {
                    name: 'sec',
                    type: 'value'
                }
            ],
            series: [
                // {
                //     name: 'MN',
                //     type: 'bar',
                //     //stack: 'motherNet',
                //     data: [120, 130, 145, 165, 195]
                // },
                {
                    name: 'MN',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 60]
                },
                {
                    name: 'HN1',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 20]
                },
                {
                    name: 'HN2',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 30]
                },
                {
                    name: 'HN3',
                    type: 'bar',
                    data: [0, 0, 0, 0, 25],
                    stack: 'motherNet'
                },
                {
                    name: 'CN1',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 70]
                },
                {
                    name: 'CN2',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 60]
                },
                {
                    name: 'CN3',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 55]
                }
            ]
        };
        setInterval(function () {
            option1.series[0].data[0] = Accuracy30_Time[5] / 1000;
            option1.series[4].data[0] = Accuracy30_Time[0] / 1000;
            option1.series[5].data[0] = Accuracy30_Time[1] / 1000;
            option1.series[6].data[0] = Accuracy30_Time[2] / 1000;


            option1.series[0].data[1] = Accuracy50_Time[5] / 1000;
            option1.series[4].data[1] = Accuracy50_Time[0] / 1000;
            option1.series[5].data[1] = Accuracy50_Time[1] / 1000;
            option1.series[6].data[1] = Accuracy50_Time[2] / 1000;


            option1.series[0].data[2] = Accuracy70_Time[5] / 1000;
            option1.series[4].data[2] = Accuracy70_Time[0] / 1000;
            option1.series[5].data[2] = Accuracy70_Time[1] / 1000;
            option1.series[6].data[2] = Accuracy70_Time[2] / 1000;

            option1.series[0].data[3] = Accuracy90_Time[5] / 1000;
            option1.series[4].data[3] = Accuracy90_Time[0] / 1000;
            option1.series[5].data[3] = Accuracy90_Time[1] / 1000;
            option1.series[6].data[3] = Accuracy90_Time[2] / 1000;
            //console.log(option1.series[0].data[0]);
            TimeCompare.setOption(option1, true);
        }, 2000);
        ;
        if (option1 && typeof option1 === "object") {
            TimeCompare.setOption(option1, true);
        }
    }

    function chart2(ec) {
        var AccLsStp = echarts.init(document.getElementById("container1"));
        var app = {};
        option = null;
        option = {
            title: {
                text: 'Live Training',
                subtext: ''
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: {
                    type: 'cross',
                    label: {
                        backgroundColor: '#d41934'
                    }
                }
            },
            legend: {
                data: ['accuracy', 'loss']
            },
            toolbox: {
                show: false,
                feature: {
                    dataView: { readOnly: false },
                    restore: {},
                    saveAsImage: {}
                }
            },
            dataZoom: {
                show: true,
                start: 0,
                end: 100
            },
            xAxis: [
                {
                    type: 'category',
                    name: 'step',
                    boundaryGap: true,
                    data: (function () {
                        var res = [];
                        var len = 10;
                        while (len--) {
                            res.unshift(0);
                        }
                        return res;
                    })()
                },
                {
                    type: 'category',
                    boundaryGap: true,
                    data: (function () {
                        var res = [];
                        var len = 10;
                        while (len--) {
                            res.push(0);
                        }
                        return res;
                    })()
                }
            ],
            yAxis: [
                {
                    type: 'value',
                    scale: true,
                    name: 'accuracy',
                    max: 1,
                    min: 0,
                    boundaryGap: [0.2, 0.2]
                },
                {
                    type: 'value',
                    scale: true,
                    name: 'loss',
                    max: 3,
                    min: 0,
                    boundaryGap: [0.2, 0.2]
                }
            ],
            series: [
                {
                    name: 'loss',
                    type: 'bar',
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    data: (function () {
                        var res = [];
                        var len = 10;
                        while (len--) {
                            res.push(0);
                        }
                        return res;
                    })()
                },
                {
                    name: 'accuracy',
                    type: 'line',
                    data: (function () {
                        var res = [];
                        var len = 0;
                        while (len < 10) {
                            res.push(0.1);
                            len++;
                        }
                        return res;
                    })()
                }
            ]
        };

        app.count = 0;
        setInterval(function () {
            axisData = STEP;
            var data0 = option.series[0].data;
            var data1 = option.series[1].data;
            data0.shift();
            if (MN_convergence === false) {
                data0.push(xLossWindow[5].get_average() + wLossWindow[5].get_average());
            }
            else if (MN_convergence === true && HN_convergence[0] === false) {
                data0.push(xLossWindow[6].get_average() + wLossWindow[6].get_average());
            }
            else if (HN_convergence[0] === true && HN_convergence[1] === false) {
                data0.push(xLossWindow[7].get_average() + wLossWindow[7].get_average());
            }
            else if (HN_convergence[1] === true && HN_convergence[2] === false) {
                data0.push(xLossWindow[8].get_average() + wLossWindow[8].get_average());
            }
            data1.shift();
            if (MN_convergence === false) {
                data1.push(trainAccWindow[5].get_average());
            }
            else if (MN_convergence === true && HN_convergence[0] === false) {
                data1.push(trainAccWindow[6].get_average());
            }
            else if (HN_convergence[0] === true && HN_convergence[1] === false) {
                data1.push(trainAccWindow[7].get_average());
            }
            else if (HN_convergence[1] === true && HN_convergence[2] === false) {
                data1.push(trainAccWindow[8].get_average());
            }

            option.xAxis[0].data.shift();
            option.xAxis[0].data.push(axisData);
            option.xAxis[1].data.shift();
            option.xAxis[1].data.push(++app.count);

            AccLsStp.setOption(option);
        }, 2000);
        ;
        if (option && typeof option === "object") {
            AccLsStp.setOption(option, true);
        }
    }

    function chart3(ec) {
        var MNmthd = echarts.init(document.getElementById("container3"));
        var app = {};
        option = null;
        var option = {
            title: {
                text: 'General Accuracy',
                subtext: ''
            },
            tooltip: {
                formatter: "{a} <br/>{b} : {c}%"
            },
            grid: {
                width: 200,
                height: 95
            },
            series: [
                {
                    name: 'General Accuracy',
                    type: 'gauge',
                    radius: '75%',
                    detail: { formatter: '{value}%' },
                    center: ['25%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            width: 4,
                            color: [
                                [1, 'rgb(12,84,83)']
                            ]
                        },
                    },
                    splitLine: {
                        length: -6,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                            width: 4
                        }
                    },
                    axisLabel: {
                        show: false
                    },
                    axisTick: {
                        splitNumber: 1,
                        lineStyle: {
                            opacity: 0,
                        }
                    },
                    detail: {
                        show: false
                    },
                    pointer: {
                        show: false
                    }
                },
                {
                    name: 'General Accuracy of MN method',
                    type: 'gauge',
                    radius: '70%',
                    center: ['25%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            opacity: 0
                        },
                    },
                    splitLine: {
                        length: 20,
                    },
                    axisLabel: {
                        distance: -80,
                        color: 'rgb(12,84,83)',
                        fontSize: 24,
                        formatter: function (param) {
                            if ((param % 50) == 0) {
                                return param
                            }
                        }
                    },
                    detail: {
                        show: false,
                        formatter: '{value}%',
                        //backgroundColor:'#fff'
                    },
                    itemStyle: {
                        normal: {
                            color: 'rgb(12,84,83)'
                        }
                    },
                    pointer: {
                        width: 10,
                        length: '90%'
                    },
                    data: [{ value: 0, name: 'MN method' }]
                },
                {
                    name: 'General Accuracy',
                    type: 'gauge',
                    radius: '75%',
                    detail: { formatter: '{value}%' },
                    center: ['75%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            width: 4,
                            color: [
                                [1, 'rgb(12,84,83)']
                            ]
                        },
                    },
                    splitLine: {
                        length: -6,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                            width: 4
                        }
                    },
                    axisLabel: {
                        show: false
                    },
                    axisTick: {
                        splitNumber: 1,
                        lineStyle: {
                            opacity: 0,
                        }
                    },
                    detail: {
                        show: false
                    },
                    pointer: {
                        show: false
                    }
                },
                {
                    name: 'General Accuracy of Baseline method',
                    type: 'gauge',
                    radius: '70%',
                    center: ['75%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            opacity: 0
                        },
                    },
                    splitLine: {
                        length: 20,
                    },
                    axisLabel: {
                        distance: -80,
                        color: 'rgb(12,84,83)',
                        fontSize: 24,
                        formatter: function (param) {
                            if ((param % 50) == 0) {
                                return param
                            }
                        }
                    },
                    detail: {
                        show: false,
                        formatter: '{value}%',
                        //backgroundColor:'#fff'
                    },
                    itemStyle: {
                        normal: {
                            color: 'rgb(12,84,83)'
                        }
                    },
                    pointer: {
                        width: 10,
                        length: '90%'
                    },
                    data: [{ value: 0, name: 'Baseline method' }]
                }
            ]
        };

        setInterval(function () {
            option.series[1].data[0].value = (MN_EA * 100).toFixed(2) - 0;
            option.series[3].data[0].value = (Baseline_EA * 100).toFixed(2) - 0;
            MNmthd.setOption(option, true);
        }, 2000);
        ;
        if (option && typeof option === "object") {
            MNmthd.setOption(option, true);
        }
    }

    function chart4(ec) {
        var timeCmpr = echarts.init(document.getElementById("container4"));
        var app = {};
        option4 = null;
        app.title = '';

        option4 = {
            title: {
                text: 'Training Time',
                subtext: 'Mother Net method vs Baseline method'
            },
            tooltip: {
                trigger: 'item',
                formatter: "{a} <br/>{b}: {c} ({d}%)"
            },
            legend: {
                orient: 'vertical',
                x: 'left',
                y: 'center',
                data: ['Mother Net', 'Hatched Net1', 'Hatched Net2', 'Hatched Net3', 'Child Net1', 'Child Net2', 'Child Net3']
            },
            series: [
                {
                    name: 'Training Time of MN method',
                    type: 'pie',
                    center: ['30%', '50%'],
                    radius: ['50%', '70%'],
                    avoidLabelOverlap: false,
                    label: {
                        normal: {
                            show: false,
                            position: 'center'
                        },
                        emphasis: {
                            show: true,
                            textStyle: {
                                fontSize: '30',
                                fontWeight: 'bold'
                            }
                        }
                    },
                    labelLine: {
                        normal: {
                            show: false
                        }
                    },
                    data: [
                        { value: 0, name: 'Mother Net' },
                        { value: 0, name: 'Hatched Net1' },
                        { value: 0, name: 'Hatched Net2' },
                        { value: 0, name: 'Hatched Net3' },
                        { value: 360, name: '' }
                    ]
                },
                {
                    name: 'Training Time of baseline method',
                    type: 'pie',
                    center: ['70%', '50%'],
                    radius: ['50%', '70%'],
                    avoidLabelOverlap: false,
                    label: {
                        normal: {
                            show: false,
                            position: 'center'
                        },
                        emphasis: {
                            show: true,
                            textStyle: {
                                fontSize: '30',
                                fontWeight: 'bold'
                            }
                        }
                    },
                    labelLine: {
                        normal: {
                            show: false
                        }
                    },
                    data: [
                        { value: 0, name: 'Child Net1' },
                        { value: 0, name: 'Child Net2' },
                        { value: 0, name: 'Child Net3' },
                        { value: 360, name: '' }
                    ]
                }
            ]
        };
        setInterval(function () {
            if (MN_convergence === false) {
                option4.series[0].data[0].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (MN_convergence === true && HN_convergence[0] === false) {
                option4.series[0].data[1].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (HN_convergence[0] === true && HN_convergence[1] === false) {
                option4.series[0].data[2].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (HN_convergence[1] === true && HN_convergence[2] === false) {
                option4.series[0].data[3].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            if (CN_convergence[0] === false) {
                option4.series[1].data[0].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            else if (CN_convergence[0] === true && CN_convergence[1] === false) {
                option4.series[1].data[1].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            else if (CN_convergence[1] === true && CN_convergence[2] === false) {
                option4.series[1].data[2].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            timeCmpr.setOption(option4, true);
        }, 1000);
        ;
        if (option4 && typeof option4 === "object") {
            timeCmpr.setOption(option4, true);
        }
    }


    function DrawCharts(ec) {
        //chart1(ec);
        chart2(ec);
        chart3(ec);
        chart4(ec);
    }
</script>

</html>