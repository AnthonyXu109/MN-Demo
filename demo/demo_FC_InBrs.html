<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>
        Queriosity - DASlab | Harvard University
    </title>
    <link href="../assets/img/logo_small.png" rel="icon" type="image/x-icon" />

    <!--[if IE]>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <![endif]-->
    <!-- BOOTSTRAP STYLE SHEET -->
    <link href="../assets/css/bootstrap.css" rel="stylesheet" />

    <!-- CUSTOM STYLES -->
    <link href="../assets/css/style.css" rel="stylesheet" />
    <link href="../assets/css/faa.css" rel="stylesheet" />

    <!-- Font Awesome -->
    <script src="https://use.fontawesome.com/3227f266ec.js"></script>

    <!-- HTML5 Shiv and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <style>
        /* #netDef1 {
            position: absolute;
            left: 1%;

        } */

        #netDef1 {
            position: absolute;
            left: 23.5%;

        }

        #netDef2 {
            position: absolute;
            left: 44.5%;

        }

        #netDef3 {
            position: absolute;
            left: 64.5%;

        }

        #netDef5 {
            position: absolute;
            left: 82%;

        }

        #addNet {
            position: absolute;
            left: 45%;
        }
    </style>

    <style>
        .axis .domain {
            display: none;
        }
    </style>

    <script src="jquery-1.8.3.min.js"></script>
    <script src="../build/vis.js"></script>
    <script src="../build/util.js"></script>
    <script src="../build/convnet.js"></script>
    <script src="../demo/mnist_labels.js"></script>

    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts.min.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-gl/echarts-gl.min.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-stat/ecStat.min.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"></script>
    <script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=ZUONbpqGBsYGXNIYHicvbAbM"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"></script>
    <script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/simplex.js"></script>
    <script src="http://echarts.baidu.com/build/dist/echarts.js"></script>


    <script>
        var netIndex = 1;
        var layerIndex = new Array(5);//cuz there are up to 5 child/hatched nets
        for (var i = 0; i < 5; i++) { layerIndex[i] = 10 + 10 * i + 6; }
        var neuronIndex = 30;
        var layerLog = new Array(5);//cuz there are up to 5 child/hatched nets
        for (var i = 0; i < 5; i++) { layerLog[i] = 6; }
        function addOne(layerID) {
            var temp = layerID - 1;
            var num = document.getElementById(temp);
            num.value = parseInt(num.value) + 1;
        }
        function minusOne(layerID) {
            var temp = layerID - 1;
            var num = document.getElementById(temp);
            if (num.value > 0) {
                num.value = parseInt(num.value) - 1;
            }
        }

        var layer_defs = new Array();
        var net = new Array();
        var hatched_defs = new Array();
        var hatchedNet = new Array();
        var trainer = new Array();
        var t = new Array();
        var legend = new Array();
        var startHatching = false;
        var Fwd = new Array();
        var STEP = 0;
        var Baseline_EA = 0;
        var MN_EA = 0;
        var trainStart_CN = new Array(5);
        var trainEnd_CN = new Array(5);
        var training_CN = new Array(5);
        var trainStart_MN = 0;
        var trainEnd_MN = 0;
        var training_MN = 0;
        var trainStart_HN = new Array(5);
        var trainEnd_HN = new Array(5);
        var training_HN = new Array(5);
        var Accuracy30_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy30_Time[i] = 0;
        }
        var Accuracy50_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy50_Time[i] = 0;
        }
        var Accuracy70_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy70_Time[i] = 0;
        }
        var Accuracy90_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            Accuracy90_Time[i] = 0;
        }
        var AccuracyCvg_Time = new Array(11);
        for (var i = 0; i < 11; i++) {
            AccuracyCvg_Time[i] = 0;
        }
        //for(var i = 0; i < 5 ; i++) {trainStart_HN[i] = new Date().getTime();}
        var MN_convergence = false;
        var CN_convergence = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_convergence[i] = false;
        }
        var HN_convergence = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_convergence[i] = false;
        }
        var CN_convergeACC = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_convergeACC[i] = 0;
        }
        var MN_convergeACC = 0;
        var HN_convergeACC = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_convergeACC[i] = 0;
        }
        var CN_accLog = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_accLog[i] = [0, 0, 0, 0, 0];
        }
        var CN_avgacc = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_avgacc[i] = 0;
        }
        var MN_accLog = [0, 0, 0, 0, 0];
        var MN_avgacc = 0;
        var HN_accLog = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_accLog[i] = [0, 0, 0, 0, 0];
        }
        var HN_avgacc = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_avgacc[i] = 0;
        }
        var CN_variance = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_variance[i] = 0;
        }
        var MN_variance = 0;
        var HN_variance = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_variance[i] = 0;
        }
        var CN_Max = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_Max[i] = 0;
        }
        var CN_Min = new Array(5);
        for (var i = 0; i < 5; i++) {
            CN_Min[i] = 99999;
        }
        var MN_Max = 0;
        var MN_Min = 99999;
        var HN_Max = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_Max[i] = 0;
        }
        var HN_Min = new Array(5);
        for (var i = 0; i < 5; i++) {
            HN_Min[i] = 99999;
        }
        var BATCH = 128;
        var StartDraw = false;


        //initialize MN
        var mother_defs, motherNet;
        mother_defs = [];
        mother_defs.push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });//the mother net needs an input layer by default



        //there are already three children networks by default
        t[0] = "layer_defs[0] = [];\n\
        layer_defs[0].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'fc', num_neurons:50, activation:'relu'});\n\
        layer_defs[0].push({type:'softmax', num_classes:10});\n\
        \n\
        net[0] = new convnetjs.Net();\n\
        net[0].makeLayers(layer_defs[0]);\n\
        \n\
        trainer[0] = new convnetjs.Trainer(net[0], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        t[1] = "layer_defs[1] = [];\n\
        layer_defs[1].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'fc', num_neurons:70, activation:'relu'});\n\
        layer_defs[1].push({type:'softmax', num_classes:10});\n\
        \n\
        net[1] = new convnetjs.Net();\n\
        net[1].makeLayers(layer_defs[1]);\n\
        \n\
        trainer[1] = new convnetjs.Trainer(net[1], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        t[2] = "layer_defs[2] = [];\n\
        layer_defs[2].push({type:'input', out_sx:28, out_sy:28, out_depth:1});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'fc', num_neurons:60, activation:'relu'});\n\
        layer_defs[2].push({type:'softmax', num_classes:10});\n\
        \n\
        net[2] = new convnetjs.Net();\n\
        net[2].makeLayers(layer_defs[2]);\n\
        \n\
        trainer[2] = new convnetjs.Trainer(net[2], {method:'adadelta', batch_size:50, l2_decay:0.001});\n\
        ";

        var step_num = 0;
        var maxmin = cnnutil.maxmin;
        var f2t = cnnutil.f2t;
        // ------------------------
        // BEGIN MNIST SPECIFIC STUFF
        // ------------------------
        var classes_txt = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

        var use_validation_data = true;

        var num_batches = 21; // 20 training batches, 1 test batch
        var num_bg_batches = 21;
        var test_batch = 20;
        var data_img_elts = new Array(num_batches);
        var bg_data_img_elts = new Array(num_bg_batches);
        var img_data = new Array(num_batches);
        var bg_img_data = new Array(num_bg_batches);
        var loaded = new Array(num_batches);
        var loaded_train_batches = [];

        var sample_training_instance = function () {
            // find an unloaded batch
            var bi = Math.floor(Math.random() * loaded_train_batches.length);
            var b = loaded_train_batches[bi];
            var k = Math.floor(Math.random() * 3000); // sample within the batch
            var n = b * 3000 + k;

            // load more batches over time
            if (step_num % 3000 === 0 && step_num > 0) {
                for (var i = 0; i < num_batches; i++) {
                    if (!loaded[i]) {
                        load_data_batch(i);
                        break;
                    }
                }
            }

            // fetch the appropriate row of the training image and reshape into a Vol
            var p = img_data[b].data;
            var x = new convnetjs.Vol(28, 28, 1, 0.0);
            var W = 28 * 28;
            var j = 0;
            for (var i = 0; i < W; i++) {
                var ix = ((W * k) + i) * 4;
                x.w[i] = p[ix] / 255.0;
            }

            var isval = use_validation_data && n % 10 === 0 ? true : false;
            return { x: x, label: labels[n], isval: isval };
        }

        var sample_bg_training_instance = function () {
            var bg = 0;
            var bi = Math.floor(Math.random() * loaded_train_batches.length);
            var b = loaded_train_batches[bi];
            var k = Math.floor(Math.random() * 3000);
            var n = b * 3000 + k;
            // load more batches over time
            if (step_num % 5000 === 0 && step_num > 0) {
                bg = Math.floor(Math.random() * num_batches);
                load_bg_data_batch(bg);
            }

            // fetch the appropriate row of the training image and reshape into a Vol
            var p = bg_img_data[bg].data;
            var x = new convnetjs.Vol(28, 28, 1, 0.0);
            var W = 28 * 28;
            var j = 0;
            for (var i = 0; i < W; i++) {
                var ix = ((W * k) + i) * 4;
                x.w[i] = p[ix] / 255.0;
            }

            var isval = use_validation_data && n % 10 === 0 ? true : false;
            return { x: x, label: labels[n], isval: isval };
        }

        // // sample a random testing instance
        // var sample_test_instance = function () {

        //     var b = test_batch;
        //     var k = Math.floor(Math.random() * 1000);
        //     var n = b * 1000 + k;

        //     var p = img_data[b].data;
        //     var x = new convnetjs.Vol(32, 32, 3, 0.0);
        //     var W = 32 * 32;
        //     var j = 0;
        //     for (var dc = 0; dc < 3; dc++) {
        //         var i = 0;
        //         for (var xc = 0; xc < 32; xc++) {
        //             for (var yc = 0; yc < 32; yc++) {
        //                 var ix = ((W * k) + i) * 4 + dc;
        //                 x.set(yc, xc, dc, p[ix] / 255.0 - 0.5);
        //                 i++;
        //             }
        //         }
        //     }

        //     // distort position and maybe flip
        //     var xs = [];
        //     //xs.push(x, 32, 0, 0, false); // push an un-augmented copy
        //     for (var k = 0; k < 6; k++) {
        //         var dx = Math.floor(Math.random() * 5 - 2);
        //         var dy = Math.floor(Math.random() * 5 - 2);
        //         xs.push(convnetjs.augment(x, 32, dx, dy, k > 2));
        //     }

        //     // return multiple augmentations, and we will average the network over them
        //     // to increase performance
        //     return { x: xs, label: labels[n] };
        // }

        // int main
        //$(window).load(
        Main = function () {


            layer_defs[0] = [];
            layer_defs[0].push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });
            layer_defs[0].push({ type: 'fc', num_neurons: document.getElementById(11).value, activation: 'relu' });
            layer_defs[0].push({ type: 'fc', num_neurons: document.getElementById(12).value, activation: 'relu' });
            layer_defs[0].push({ type: 'fc', num_neurons: document.getElementById(13).value, activation: 'relu' });
            layer_defs[0].push({ type: 'fc', num_neurons: document.getElementById(14).value, activation: 'relu' });
            layer_defs[0].push({ type: 'fc', num_neurons: document.getElementById(15).value, activation: 'relu' });
            layer_defs[0].push({ type: 'softmax', num_classes: 10 });

            net[0] = new convnetjs.Net();
            net[0].makeLayers(layer_defs[0]);

            trainer[0] = new convnetjs.Trainer(net[0], { method: 'adadelta', batch_size: BATCH, l2_decay: 0.001 });

            layer_defs[1] = [];
            layer_defs[1].push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });
            layer_defs[1].push({ type: 'fc', num_neurons: document.getElementById(21).value, activation: 'relu' });
            layer_defs[1].push({ type: 'fc', num_neurons: document.getElementById(22).value, activation: 'relu' });
            layer_defs[1].push({ type: 'fc', num_neurons: document.getElementById(23).value, activation: 'relu' });
            layer_defs[1].push({ type: 'fc', num_neurons: document.getElementById(24).value, activation: 'relu' });
            layer_defs[1].push({ type: 'fc', num_neurons: document.getElementById(25).value, activation: 'relu' });
            layer_defs[1].push({ type: 'softmax', num_classes: 10 });

            net[1] = new convnetjs.Net();
            net[1].makeLayers(layer_defs[1]);

            trainer[1] = new convnetjs.Trainer(net[1], { method: 'adadelta', batch_size: BATCH, l2_decay: 0.001 });

            layer_defs[2] = [];
            layer_defs[2].push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });
            layer_defs[2].push({ type: 'fc', num_neurons: document.getElementById(31).value, activation: 'relu' });
            layer_defs[2].push({ type: 'fc', num_neurons: document.getElementById(31).value, activation: 'relu' });
            layer_defs[2].push({ type: 'fc', num_neurons: document.getElementById(31).value, activation: 'relu' });
            layer_defs[2].push({ type: 'fc', num_neurons: document.getElementById(31).value, activation: 'relu' });
            layer_defs[2].push({ type: 'fc', num_neurons: document.getElementById(31).value, activation: 'relu' });
            layer_defs[2].push({ type: 'softmax', num_classes: 10 });

            net[2] = new convnetjs.Net();
            net[2].makeLayers(layer_defs[2]);

            trainer[2] = new convnetjs.Trainer(net[2], { method: 'adadelta', batch_size: BATCH, l2_decay: 0.001 });
            for (var i = 0; i < 3; i++) {
                // $("#newnet" + i).val(t[i]);
                // eval($("#newnet" + i).val());
                hatched_defs[i] = [];
                hatched_defs[i] = layer_defs[i];
                hatchedNet[i] = new convnetjs.Net();
                hatchedNet[i].makeLayers(hatched_defs[i]);
                trainer[i + 6] = new convnetjs.SGDTrainer(hatchedNet[i], { method: 'adadelta', batch_size: BATCH, l2_decay: 0.001 });
                legend[i] = 'childNet ' + i;
            }


            // for(var i=0;legend[i];i++){
            //     console.log(legend[i]);
            // }


            //we built mother network here based on layer definitions of each child network
            //we look at all the children networks at all convolutional layers (so we skip Input, pooling and softmax layers)
            //, and add the one with fewest filters into the mother network.
            //find the longest childnet who have the most layers
            var longestLength = 0;
            var temp_neuronNum = 10000;
            for (var n = 0; n < layer_defs.length; n++) {
                if (longestLength < layer_defs[n].length) {
                    longestLength = layer_defs[n].length;
                }
            }
            //loop for all positions but skip the input layer and softmax layer.
            for (var i = 1; i < longestLength - 1; i++) {
                temp_neuronNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'fc' && layer_defs[j][i].num_neurons < temp_neuronNum && layer_defs[j][i].num_neurons > 0) {
                        temp_neuronNum = layer_defs[j][i].num_neurons;

                    }
                }

                mother_defs.push({ type: 'fc', num_neurons: temp_neuronNum, activation: 'relu' });
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it
            trainer[5] = new convnetjs.Trainer(motherNet, { method: 'adadelta', batch_size: BATCH, l2_decay: 0.001 });

            //for now, we show the motherNet by simply print each layer
            // var m2t = document.getElementById("MotherNet_vis");
            // m2t.innerHTML = '';
            // for (var i = 0; mother_defs[i]; i++) {
            //     if (i == 0) {
            //         var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
            //         m2t.appendChild(document.createTextNode(mt));
            //         m2t.appendChild(document.createElement('br'));
            //     }
            //     else if (mother_defs[i].type === 'fc') {
            //         var mt = 'Fully connected layer:' + ' num_neurons:' + mother_defs[i].num_neurons + ' activation:' + mother_defs[i].activation;
            //         m2t.appendChild(document.createTextNode(mt));
            //         m2t.appendChild(document.createElement('br'));
            //     }
            //     else if (i == mother_defs.length - 1) {
            //         var mt = 'Softmax layer: number of classes: 10';//since we are using MNIST
            //         m2t.appendChild(document.createTextNode(mt));
            //     }
            // }


            for (var k = 0; k < loaded.length; k++) { loaded[k] = false; }

            load_data_batch(0); // async load train set batch 0 (6 total train batches)
            load_data_batch(test_batch); // async load test set (batch 6)
            load_bg_data_batch(0);
            load_bg_data_batch(test_batch);
            for (var i = 0; i < 5; i++) { trainStart_CN[i] = new Date().getTime(); }
            trainStart_MN = new Date().getTime();
            start_fun();
            StartDraw = true;
            //bg_start_fun();
        }
        //);

        var start_fun = function () {
            if (loaded[0] && loaded[test_batch]) {
                console.log('starting!');
                setInterval(load_and_step, 0);
            }
            else { setTimeout(start_fun, 200); } // keep checking
            //setInterval(widenNets(motherNet, hatchedNet), 1000); //use Mother Network to update hatched networks every 1 sec
        }
        /*
                //hatched part
                var bg_start_fun = function () {
                    if (loaded[test_batch]) {
                        console.log('BG starting!');
                        setInterval(bg_load_and_step, 100);
                    }
                    else { setTimeout(bg_start_fun, 200); }
                }
        */
        var load_data_batch = function (batch_num) {
            // Load the dataset with JS in background
            data_img_elts[batch_num] = new Image();
            var data_img_elt = data_img_elts[batch_num];
            data_img_elt.onload = function () {
                var data_canvas = document.createElement('canvas');
                data_canvas.width = data_img_elt.width;
                data_canvas.height = data_img_elt.height;
                var data_ctx = data_canvas.getContext("2d");
                data_ctx.drawImage(data_img_elt, 0, 0); // copy it over... bit wasteful :(
                img_data[batch_num] = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
                loaded[batch_num] = true;
                if (batch_num < 20) { loaded_train_batches.push(batch_num); }
                console.log('finished loading data batch ' + batch_num);
            };
            data_img_elt.src = "mnist_batch_" + batch_num + ".png";
        }

        var load_bg_data_batch = function (batch_num) {
            // Load the dataset with JS in background
            bg_data_img_elts[batch_num] = new Image();
            var bg_data_img_elt = bg_data_img_elts[batch_num];
            bg_data_img_elt.onload = function () {
                var bg_data_canvas = document.createElement('canvas');
                bg_data_canvas.width = bg_data_img_elt.width;
                bg_data_canvas.height = bg_data_img_elt.height;
                var bg_data_ctx = bg_data_canvas.getContext("2d");
                bg_data_ctx.drawImage(bg_data_img_elt, 0, 0); // copy it over... bit wasteful :(
                bg_img_data[batch_num] = bg_data_ctx.getImageData(0, 0, bg_data_canvas.width, bg_data_canvas.height);
                console.log('finished loading bagging data batch ' + batch_num);
            };
            bg_data_img_elt.src = "mnist_batch_" + batch_num + ".png";
        }


        // ------------------------
        // END MNIST SPECIFIC STUFF
        // ------------------------

        // loads a training image and trains on it with the Children Networks and Mother Network
        var paused = false;
        var embed_samples = [];
        var embed_imgs = [];
        var load_and_step = function () {
            if (paused) return;

            // if (embed_samples.length === 0) { // happens once
            //     for (var k = 0; k < 200; k++) {
            //         var s = sample_training_instance();
            //         embed_samples.push(s);
            //         // render x and save it too
            //         var I = render_act(s.x);
            //         embed_imgs.push(I);
            //     }
            // }
            var sample = sample_training_instance();
            step(sample); // process this image
        }
        // the hatchedNet part
        var embed_bg_samples = [];
        var embed_bg_imgs = [];
        var bg_load_and_step = function () {
            if (paused) return;

            if (embed_bg_samples.length === 0) {
                for (var k = 0; k < 200; k++) {
                    var s = sample_bg_training_instance();
                    embed_bg_samples.push(s);
                    var I = render_act(s.x);
                    embed_bg_imgs.push(I);
                }
            }
            var sample = sample_bg_training_instance();
            bg_step(sample);
        }

        //var lossGraph = new cnnvis.MultiGraph(legend, );
        var xLossWindow = new Array();
        var wLossWindow = new Array();
        var trainAccWindow = new Array();
        var valAccWindow = new Array();
        var testAccWindow = new Array();
        var MNtempAcc = 0;//log the temporary accuracy of MN every 500 steps
        for (var i = 0; i < 5; i++) {
            xLossWindow[i] = new cnnutil.Window(100);
            wLossWindow[i] = new cnnutil.Window(100);
            trainAccWindow[i] = new cnnutil.Window(100);
            valAccWindow[i] = new cnnutil.Window(100);
            testAccWindow[i] = new cnnutil.Window(100);
        }
        //the MN part
        xLossWindow[5] = new cnnutil.Window(100);
        wLossWindow[5] = new cnnutil.Window(100);
        trainAccWindow[5] = new cnnutil.Window(100);
        valAccWindow[5] = new cnnutil.Window(100);
        testAccWindow[5] = new cnnutil.Window(100);
        //temp hatchedNet part
        for (var i = 6; i < 10; i++) {
            xLossWindow[i] = new cnnutil.Window(100);
            wLossWindow[i] = new cnnutil.Window(100);
            trainAccWindow[i] = new cnnutil.Window(100);
            valAccWindow[i] = new cnnutil.Window(100);
            testAccWindow[i] = new cnnutil.Window(100);
        }
        //the HatchedNet part
        var bg_xLossWindow = new Array();
        var bg_wLossWindow = new Array();
        var bg_trainAccWindow = new Array();
        var bg_valAccWindow = new Array();
        var bg_testAccWindow = new Array();
        for (var i = 0; i < 5; i++) {
            bg_xLossWindow[i] = new cnnutil.Window(100);
            bg_wLossWindow[i] = new cnnutil.Window(100);
            bg_trainAccWindow[i] = new cnnutil.Window(100);
            bg_valAccWindow[i] = new cnnutil.Window(100);
            bg_testAccWindow[i] = new cnnutil.Window(100);
        }












        var step = function (sample) {

            // if (step_num % 500 === 0 && step_num > 0) {

            //     widenNets(motherNet, hatchedNet);

            // }





            var x = sample.x;
            var y = sample.label;
            var stats = new Array();
            var lossx = new Array();
            var lossw = new Array();


            if (sample.isval) {
                var yhat = new Array();
                var val_acc = new Array();
                // use x to build our estimate of validation error
                for (var i = 0; net[i]; i++) {
                    net[i].forward(x);
                    yhat[i] = net[i].getPrediction();
                    val_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                    valAccWindow[i].add(val_acc[i]);
                }
                //the MN part
                motherNet.forward(x);
                yhat[5] = motherNet.getPrediction();
                val_acc[5] = yhat[5] === y ? 1.0 : 0.0;
                valAccWindow[5].add(val_acc[5]);
                //temp hatchedNet part
                for (var i = 0; hatchedNet[i]; i++) {
                    hatchedNet[i].forward(x);
                    yhat[i + 6] = hatchedNet[i].getPrediction();
                    val_acc[i + 6] = yhat[i + 6] === y ? 1.0 : 0.0;
                    valAccWindow[i + 6].add(val_acc[i + 6]);
                }
                return;
            }

            //Now, we train MN method and baseline method at the same time, but we train networks in both of these methods sequentially
            // train on it with networks
            for (var i = 0; net[i]; i++) {
                if (i === 0 && CN_convergence[0] === false) {
                    stats[i] = trainer[i].train(x, y);
                    lossx[i] = stats[i].cost_loss;
                    lossw[i] = stats[i].l2_decay_loss;
                    xLossWindow[i].add(lossx[i]);
                    wLossWindow[i].add(lossw[i]);
                }
                else if (i > 0 && CN_convergence[i - 1] === true && CN_convergence[i] === false) {
                    stats[i] = trainer[i].train(x, y);
                    lossx[i] = stats[i].cost_loss;
                    lossw[i] = stats[i].l2_decay_loss;
                    xLossWindow[i].add(lossx[i]);
                    wLossWindow[i].add(lossw[i]);
                }
            }
            //the MN part
            if (MN_convergence === false) {
                stats[5] = trainer[5].train(x, y);
                lossx[5] = stats[5].cost_loss;
                lossw[5] = stats[5].l2_decay_loss;
                xLossWindow[5].add(lossx[5]);
                wLossWindow[5].add(lossw[5]);
            }
            //temp hatchedNet part
            else if (MN_convergence === true) {
                for (var i = 0; hatchedNet[i]; i++) {
                    if (i === 0 && HN_convergence[0] === false) {
                        stats[i + 6] = trainer[i + 6].train(x, y);
                        lossx[i + 6] = stats[i + 6].cost_loss;
                        lossw[i + 6] = stats[i + 6].l2_decay_loss;
                        xLossWindow[i + 6].add(lossx[i + 6]);
                        wLossWindow[i + 6].add(lossw[i + 6]);
                    }
                    else if (i > 0 && HN_convergence[i - 1] === true && HN_convergence[i] === false) {
                        stats[i + 6] = trainer[i + 6].train(x, y);
                        lossx[i + 6] = stats[i + 6].cost_loss;
                        lossw[i + 6] = stats[i + 6].l2_decay_loss;
                        xLossWindow[i + 6].add(lossx[i + 6]);
                        wLossWindow[i + 6].add(lossw[i + 6]);
                    }
                }
            }


            // keep track of stats such as the average training error and loss
            var yhat = new Array();
            var train_acc = new Array();
            for (var i = 0; net[i]; i++) {
                yhat[i] = net[i].getPrediction();
                train_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                trainAccWindow[i].add(train_acc[i]);
            }
            //the MN part
            yhat[5] = motherNet.getPrediction();
            train_acc[5] = yhat[5] === y ? 1.0 : 0.0;
            trainAccWindow[5].add(train_acc[5]);
            //temp hatchedNet part
            for (var i = 0; hatchedNet[i]; i++) {
                yhat[i + 6] = hatchedNet[i].getPrediction();
                train_acc[i + 6] = yhat[i + 6] === y ? 1.0 : 0.0;
                trainAccWindow[i + 6].add(train_acc[i + 6]);
            }

            /*
                        // visualize training status
                        var train_elt = document.getElementById("trainstats");
                        train_elt.innerHTML = '';
                        for (var i = 0; net[i]; i++) {
                            var T = 'Forward time of network' + i + ' per example: ' + stats[i].fwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Forward time of MotherNetwork per example: ' + stats[5].fwd_time + 'ms';
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Forward time of hatched network' + i + ' per example: ' + stats[i + 6].fwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Backprop time of network' + i + ' per example: ' + stats[i].bwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Backprop time of MotherNetwork per example: ' + stats[5].bwd_time + 'ms';
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Backprop time of hatched network' + i + ' per example: ' + stats[i + 6].bwd_time + 'ms';
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Classification loss of network' + i + ' : ' + f2t(xLossWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Classification loss of MotherNetwork: ' + f2t(xLossWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Classification loss of hatched network' + i + ' : ' + f2t(xLossWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'L2 Weight decay loss of network' + i + ' : ' + f2t(wLossWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'L2 Weight decay loss of MotherNetwork: ' + f2t(wLossWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'L2 Weight decay loss of hatched network' + i + ' : ' + f2t(wLossWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Training accuracy of network' + i + ' : ' + f2t(trainAccWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Training accuracy of MotherNetwork: ' + f2t(trainAccWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Training accuracy of hatched network' + i + ' : ' + f2t(trainAccWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        for (var i = 0; net[i]; i++) {
                            var T = 'Validation accuracy of network' + i + ' : ' + f2t(valAccWindow[i].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Validation accuracy of MotherNetwork: ' + f2t(valAccWindow[5].get_average());
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
                        for (var i = 0; hatchedNet[i]; i++) {
                            var T = 'Validation accuracy of hatched network' + i + ' : ' + f2t(valAccWindow[i + 6].get_average());
                            train_elt.appendChild(document.createTextNode(T));
                            train_elt.appendChild(document.createElement('br'));
                        }
                        var T = 'Examples seen: ' + step_num;
                        train_elt.appendChild(document.createTextNode(T));
                        train_elt.appendChild(document.createElement('br'));
            */

            // // log progress to graph, (full loss)
            // if (step_num % 100 === 0 && step_num >= 200) {
            //     var Y = new Array();
            //     for (var i = 0; i < net.length; i++) {
            //         var xa = xLossWindow[i].get_average();
            //         var xw = wLossWindow[i].get_average();
            //         if (xa >= 0 && xw >= 0) { // if they are -1 it means not enough data was accumulated yet for estimates
            //             Y[i] = xa + xw;
            //         }
            //     }
            //     if (xLossWindow[5].get_average() >= 0 && wLossWindow[5].get_average() >= 0) {
            //         Y.push(xLossWindow[5].get_average() + wLossWindow[5].get_average());
            //     }
            //     // for (var i = 0; i < hatchedNet.length; i++) {
            //     //     Y.push(xLossWindow[i + 6].get_average() + wLossWindow[i + 6].get_average());
            //     // }
            //     lossGraph.add(step_num, Y);
            //     lossGraph.drawSelf(document.getElementById("lossgraph"));


            // }

            // if(isNaN(hatchedNet[1].layers[3].filters[1].w[1])){
            //     console.log(step_num);
            // }

            //compute the ensemble averaging accuracy
            Baseline_EA = 0;
            if (CN_convergence[0] && CN_convergence[1] && CN_convergence[2]) {
                for (var i = 0; net[i]; i++) {
                    Baseline_EA += CN_convergeACC[i];
                    //console.log(Baseline_EA);
                }
                Baseline_EA /= net.length;
            }
            MN_EA = 0;
            if (HN_convergence[0] && HN_convergence[1] && HN_convergence[2]) {
                for (var i = 0; hatchedNet[i]; i++) {
                    MN_EA += HN_convergeACC[i];
                    //console.log(trainAccWindow[i + 6].get_average());
                }
                MN_EA /= hatchedNet.length;
            }

            //compute training time
            //30% acc time
            if (Accuracy30_Time[0] === 0 || Accuracy30_Time[1] === 0 || Accuracy30_Time[2] === 0) {
                for (var n = 0; net[n]; n++) {
                    if (trainAccWindow[n].get_average() > 0.3 && trainAccWindow[n].get_average() < 0.5 && Accuracy30_Time[n] === 0) {

                        trainEnd_CN[n] = new Date().getTime();
                        Accuracy30_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                        //console.log(Accuracy30_Time[n]);
                    }
                }
            }
            if (trainAccWindow[5].get_average() > 0.3 && trainAccWindow[5].get_average() < 0.5 && Accuracy30_Time[5] === 0) {

                trainEnd_MN = new Date().getTime();
                Accuracy30_Time[5] = trainEnd_MN - trainStart_MN;

            }

            //50% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.5 && trainAccWindow[n].get_average() < 0.7 && Accuracy50_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy50_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.5 && trainAccWindow[5].get_average() < 0.7 && Accuracy50_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy50_Time[5] = trainEnd_MN - trainStart_MN;
            }

            //70% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.7 && trainAccWindow[n].get_average() < 0.9 && Accuracy70_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy70_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.7 && trainAccWindow[5].get_average() < 0.9 && Accuracy70_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy70_Time[5] = trainEnd_MN - trainStart_MN;
            }

            //90% acc time
            for (var n = 0; net[n]; n++) {
                if (trainAccWindow[n].get_average() > 0.9 && Accuracy90_Time[n] === 0) {
                    trainEnd_CN[n] = new Date().getTime();
                    Accuracy90_Time[n] = trainEnd_CN[n] - trainStart_CN[n];
                }
            }
            if (trainAccWindow[5].get_average() > 0.9 && Accuracy90_Time[5] === 0) {
                trainEnd_MN = new Date().getTime();
                Accuracy90_Time[5] = trainEnd_MN - trainStart_MN;
            }


            // if (step_num %300===0) {

            // }

            for (var i = 0; net[i]; i++) {
                CN_accLog[i][STEP % 5] = trainAccWindow[i].get_average();
            }
            MN_accLog[STEP % 5] = trainAccWindow[5].get_average();
            for (var i = 0; hatchedNet[i]; i++) {
                HN_accLog[i][STEP % 5] = trainAccWindow[i + 6].get_average();
            }
            for (var i = 0; net[i]; i++) {
                for (var j = 0; j < 5; j++) {
                    if (CN_accLog[i][j] > CN_Max[i]) {
                        CN_Max[i] = CN_accLog[i][j];
                    }
                    if (CN_accLog[i][j] < CN_Min[i]) {
                        CN_Min[i] = CN_accLog[i][j];
                    }
                }
            }
            for (var j = 0; j < 5; j++) {
                if (MN_accLog[j] > MN_Max) {
                    MN_Max = MN_accLog[j];
                }
                if (MN_accLog[j] < MN_Min) {
                    MN_Min = MN_accLog[j];
                }
            }
            for (var i = 0; hatchedNet[i]; i++) {
                for (var j = 0; j < 5; j++) {
                    if (HN_accLog[i][j] > HN_Max[i]) {
                        HN_Max[i] = HN_accLog[i][j];
                    }
                    if (HN_accLog[i][j] < HN_Min[i]) {
                        HN_Min[i] = HN_accLog[i][j];
                    }
                }
            }
            for (var i = 0; net[i]; i++) {
                for (var n = 0; n < 5; n++) {
                    CN_avgacc[i] += CN_accLog[i][n];
                }
                CN_avgacc[i] /= 5;
            }
            for (var n = 0; n < 5; n++) {
                MN_avgacc += MN_accLog[n];
            }
            MN_avgacc /= 5;
            for (var i = 0; hatchedNet[i]; i++) {
                for (var n = 0; n < 5; n++) {
                    HN_avgacc[i] += HN_accLog[i][n];
                }
                HN_avgacc[i] /= 5;
            }
            for (var i = 0; net[i]; i++) {
                for (var j = 0; j < 5; j++) {
                    if (CN_accLog[i][j] - CN_avgacc[i] > 0) {
                        CN_variance[i] += (CN_accLog[i][j] - CN_avgacc[i]);
                    }
                    else {
                        CN_variance[i] -= (CN_accLog[i][j] - CN_avgacc[i]);
                    }
                }
                CN_variance[i] /= 5;
                //console.log(CN_variance);
            }
            for (var i = 0; i < 5; i++) {
                if (MN_accLog[i] - MN_avgacc > 0) {
                    MN_variance += (MN_accLog[i] - MN_avgacc);
                }
                else {
                    MN_variance -= (MN_accLog[i] - MN_avgacc);
                }
            }
            MN_variance /= 5;
            for (var i = 0; hatchedNet[i]; i++) {
                for (var j = 0; j < 5; j++) {
                    if (HN_accLog[i][j] - HN_avgacc[i] > 0) {
                        HN_variance[i] += (HN_accLog[i][j] - HN_avgacc[i]);
                    }
                    else {
                        HN_variance[i] -= (HN_accLog[i][j] - HN_avgacc[i]);
                    }
                }
                HN_variance[i] /= 5;
            }


            //judge the convergence
            for (var i = 0; net[i]; i++) {
                if (CN_Max[i] - CN_Min[i] < 0.93 && trainAccWindow[i].get_average() > 0.91 && CN_convergence[i] === false) {
                    CN_convergence[i] = true;
                    CN_convergeACC[i] = trainAccWindow[i].get_average();
                }
            }
            if (MN_Max - MN_Min < 0.93 && trainAccWindow[5].get_average() > 0.91 && MN_convergence === false) {
                MN_convergence = true;
                widenNets(motherNet, hatchedNet);
                MN_convergeACC = trainAccWindow[5].get_average();
            }
            for (var i = 0; hatchedNet[i]; i++) {
                if (HN_Max[i] - HN_Min[i] < 0.93 && trainAccWindow[i + 6].get_average() > 0.91 && HN_convergence[i] === false) {
                    HN_convergence[i] = true;
                    HN_convergeACC[i] = trainAccWindow[i + 6].get_average();
                }
            }
            //trainAccWindow[i].get_average() > 0.91 &&
            //trainAccWindow[5].get_average() > 0.91 &&
            //trainAccWindow[i + 6].get_average() > 0.91 &&


            step_num++;
            STEP = step_num;
        }




        //widening function
        function widenNets(motherNet, hatchedNet) {
            // console.log(motherNet.layers[3].filters);
            // for (var i = 0; hatchedNet[i]; i++) {
            //     console.log(hatchedNet[i].layers[3].filters);
            // }
            //For the original part in MN, just copy them
            for (var l = 1; l < motherNet.layers.length - 3; l++) { //loop by each hidden fc layer in MN
                if (motherNet.layers[l].layer_type === 'fc') {
                    for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //loop by each "filter" in a certain fc layer, "filter" in fc net means neuron
                        for (var i = 0; i < motherNet.layers[l].filters[f].w.length; i++) { //loop by each weight in a certain "filter"
                            for (var j = 0; hatchedNet[j]; j++) { //copy the weight to every hatchedNet
                                hatchedNet[j].layers[l].filters[f].w[i] = motherNet.layers[l].filters[f].w[i];
                            }
                        }
                    }
                }
            }
            //For the widened part, use the random select
            for (var h = 0; hatchedNet[h]; h++) { //widen each hatchedNet one by one
                for (var l = 1; l < motherNet.layers.length - 3; l++) { //loop by each fc layer in MN except for the last one
                    if (motherNet.layers[l].layer_type === 'fc') {
                        var rdmSlct = 0;
                        var copyCount = new Array(motherNet.layers[l].filters.length), i = copyCount.length; //count how many times has a filter in a certain layer of MN been copied
                        while (i--) { copyCount[i] = 0; } //initialize them with 0
                        var copyPosition = new Array(motherNet.layers[l].filters.length); //log the position in hatchedNet which copied the a certain filter of MN
                        for (var j = 0; j < copyPosition.length; j++) { //initialize them with 0
                            copyPosition[j] = new Array(hatchedNet[h].layers[l].filters.length - motherNet.layers[l].filters.length);
                            for (var k = 0; k < copyPosition[j].length; k++) {
                                copyPosition[j][k] = 0;
                            }
                        }
                        if (motherNet.layers[l].filters.length < hatchedNet[h].layers[l].filters.length) {
                            for (var f = motherNet.layers[l].filters.length; f < hatchedNet[h].layers[l].filters.length; f++) { //build the widened part in a certain layer
                                //console.log(f);
                                rdmSlct = randomFrom(0, motherNet.layers[l].filters.length); //randomly select a filter in the layer l of MN
                                //console.log(copyPosition[rdmSlct][f - motherNet.layers[l].filters.length]+','+rdmSlct+','+(f - motherNet.layers[l].filters.length));
                                hatchedNet[h].layers[l].filters[f] = hatchedNet[h].layers[l].filters[rdmSlct]; //copy it to the filter f in the widened part of layer l in hatchedNet
                                copyCount[rdmSlct]++; //log the copyCount
                                copyPosition[rdmSlct][f - motherNet.layers[l].filters.length] = 1; //log the copy position
                            }
                        }

                        if (motherNet.layers[l + 2].layer_type === 'fc') {
                            for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //for the copied filter f in layer l, we divide the counter part, weight f in every filter of layer l+1 of MN original part, by copyCount+1
                                if (copyCount[f] > 0) {
                                    for (var nxt = 0; nxt < motherNet.layers[l + 2].filters.length; nxt++) { //deal with the next layer
                                        hatchedNet[h].layers[l + 2].filters[nxt].w[f] /= (copyCount[f] + 1);
                                        for (var i = motherNet.layers[l].filters.length; i < hatchedNet[h].layers[l].filters.length; i++) { //for the filters in widened part who copied the filter f in MN, we use the updated filter in MN original part to update them
                                            if (copyPosition[f][i - motherNet.layers[l].filters.length] === 1) {
                                                hatchedNet[h].layers[l + 2].filters[nxt].w[i] = hatchedNet[h].layers[l + 2].filters[nxt].w[f];
                                                if (step_num > 700 && step_num < 900) { console.log(hatchedNet[h].layers[l + 2].filters[nxt].w[i]); }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }



        //build the hatched networks
        //generate a random integer
        function randomFrom(lowerValue, upperValue) {
            return Math.floor(Math.random() * (upperValue - lowerValue) + lowerValue);
        }
        //Hatch function
        function Hatch(motherNet, hatchedNet) {
            //For the original part in MN, just copy them
            for (var l = 0; l < motherNet.layers.length - 3; l++) { //loop by each hidden fc layer in MN
                if (motherNet.layers[l].layer_type === 'fc') {
                    //console.log(l);
                    for (var f = 0; f < motherNet.layers[l].filters.length; f++) { //loop by each "filter" in a certain fc layer
                        for (var i = 0; i < motherNet.layers[l].filters[f].w.length; i++) { //loop by each weight in a certain "filter"
                            for (var j = 0; hatchedNet[j]; j++) { //copy the weight to every hatchedNet
                                hatchedNet[j].layers[l].filters[f].w[i] = motherNet.layers[l].filters[f].w[i];
                            }
                        }
                    }
                }
                else {
                    console.log(motherNet.layers[l].layer_type);
                }
            }
            //deepen hatchedNets now
            var Len = motherNet.layers[motherNet.layers.length - 4].filters.length;//the size of the last fc layer in MN. (every fc layer is followed by an activation layer and another fc layer is inserted before softmax without activation(this fc layer should be ignored))
            for (var h = 0; hatchedNet[h]; h++) {//loop by every hatchedNet
                if (motherNet.layers.length < hatchedNet[h].layers.length) {//find a hatchedNet needed to be deepen
                    for (var l = motherNet.layers.length - 2; l < hatchedNet[h].layers.length - 3; l++) {//loop by every deepened hidden layer in HN
                        if (hatchedNet[h].layers[l].layer_type === 'fc') {
                            for (var f = 0; f < hatchedNet[h].layers[l].filters.length; f++) {//loop by every "filter" in deepened layer l in HN
                                for (var p = 0; p < hatchedNet[h].layers[l].filters[f].length; p++) {//loop by every parameter in filter f
                                    hatchedNet[h].layers[l].filters[f].w[p] = 0;
                                }
                                if (f < Len) {
                                    hatchedNet[h].layers[l].filters[f].w[f] = 1;
                                }
                            }
                        }
                    }
                    //preserve the output and pad 0
                    for (var F = 0; F < hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters.length; F++) {
                        for (var P = 0; P < hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].length; P++) {
                            if (P < motherNet.layers[motherNet.layers.length - 2].filters[F].length) {
                                hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].w[P] = motherNet.layers[motherNet.layers.length - 2].filters[F].w[P];
                            }
                            hatchedNet[h].layers[hatchedNet[h].layers.length - 2].filters[F].w[P] = 0;
                        }
                    }
                }
            }

            //For the widened part, use the random select
            for (var h = 0; hatchedNet[h]; h++) { //widen each hatchedNet one by one
                var L = 0;
                for (var l = 1; l < hatchedNet[h].layers.length - 3; l++) { //loop by each fc layer in HN except for the last one
                    if (l <= motherNet.layers.length - 4) {
                        L = l;
                    }
                    else { //L represents the last hidden layer in MN if l has been bigger than MN's length(without softmax and the inserted fc)
                        L = motherNet.layers.length - 4;
                    }
                    if (hatchedNet[h].layers[l].layer_type === 'fc') {
                        var rdmSlct = 0;
                        var copyCount = new Array(motherNet.layers[L].filters.length), i = copyCount.length; //count how many times has a filter in a certain layer of MN part been copied
                        while (i--) { copyCount[i] = 0; } //initialize them with 0
                        var copyPosition = new Array(motherNet.layers[L].filters.length); //log the position in hatchedNet which copied the a certain filter of MN
                        for (var j = 0; j < copyPosition.length; j++) { //initialize them with 0
                            copyPosition[j] = new Array(hatchedNet[h].layers[l].filters.length - motherNet.layers[l].filters.length);
                            for (var k = 0; k < copyPosition[j].length; k++) {
                                copyPosition[j][k] = 0;
                            }
                        }
                        for (var f = motherNet.layers[L].filters.length; f < hatchedNet[h].layers[l].filters.length; f++) { //build the widened part in a certain layer
                            rdmSlct = randomFrom(0, motherNet.layers[L].filters.length); //randomly select a filter in the layer l of MN
                            //console.log(copyPosition[rdmSlct][f - motherNet.layers[l].filters.length]+','+rdmSlct+','+(f - motherNet.layers[l].filters.length));
                            hatchedNet[h].layers[l].filters[f] = hatchedNet[h].layers[l].filters[rdmSlct]; //copy it to the filter f in the widened part of layer l in hatchedNet
                            copyCount[rdmSlct]++; //log the copyCount
                            copyPosition[rdmSlct][f - motherNet.layers[L].filters.length] = 1; //log the copy position
                        }
                        if (hatchedNet[h].layers[l + 2].layer_type === 'fc') {
                            for (var nxt = 0; nxt < motherNet.layers[l + 2].filters.length; nxt++) { //deal with the next layer
                                for (var f = 0; f < motherNet.layers[L].filters.length; f++) { //for the copied filter f in layer l, we divide the counter part, weight f in every filter of layer l+1 of MN original part, by copyCount+1
                                    if (copyCount[f] > 0) {
                                        hatchedNet[h].layers[l + 2].filters[nxt].w[f] /= (copyCount[f] + 1);
                                        for (var i = motherNet.layers[L].filters.length; i < hatchedNet[h].layers[l].filters.length; i++) { //for the filters in widened part who copied the filter f in MN, we use the updated filter in MN original part to update them
                                            if (copyPosition[f][i - motherNet.layers[L].filters.length] === 1) {
                                                hatchedNet[h].layers[l + 2].filters[i] = hatchedNet[h].layers[l + 2].filters[nxt];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        var reset_all = function () {
            // reinit trainer
            trainer = new Array();
            for (var i = 0; net[i]; i++) {
                trainer[i] = new convnetjs.SGDTrainer(net[i], { method: 'adadelta', batch_size: 4, l2_decay: 0.0001 });
            }

            // reinit windows that keep track of val/train accuracies
            for (var i = 0; $("#newnet" + i).val(); i++) {
                xLossWindow[i].reset();
                wLossWindow[i].reset();
                trainAccWindow[i].reset();
                valAccWindow[i].reset();
                testAccWindow[i].reset();
            }

            step_num = 0;


        }

        var change_net = function () {
            layer_defs = [];
            net = [];
            for (var i = 0; $("#newnet" + i).val(); i++) {
                eval($("#newnet" + i).val());
            }
            reset_all();


            //I'm lazy now, so just paste the code above :(
            mother_defs = [];
            mother_defs.push({ type: 'input', out_sx: 28, out_sy: 28, out_depth: 1 });//the mother net needs an input layer by default
            var longestLength = 0;
            for (var n = 0; n < layer_defs.length; n++) {
                if (longestLength < layer_defs[n].length) {
                    longestLength = layer_defs[n].length;
                }
            }
            //loop for all positions but skip the input layer and softmax layer.
            for (var i = 1; i < longestLength - 1; i++) {
                var temp_neuronNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'fc' && layer_defs[j][i].num_neurons < temp_neuronNum && layer_defs[j][i].num_neurons > 0) {
                        temp_neuronNum = layer_defs[j][i].num_neurons;
                    }
                }
                mother_defs.push({ type: 'fc', num_neurons: temp_neuronNum, activation: 'relu' });
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it

            //for now, we show the motherNet by simply print each layer
            // var m2t = document.getElementById("MotherNet_vis");
            // m2t.innerHTML = '';
            // for (var i = 0; mother_defs[i]; i++) {
            //     if (i == 0) {
            //         var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
            //         m2t.appendChild(document.createTextNode(mt));
            //         m2t.appendChild(document.createElement('br'));
            //     }
            //     else if (mother_defs[i].type === 'fc') {
            //         console.log(i);
            //         var mt = 'Fully connected layer:' + ' num_neurons:' + mother_defs[i].num_neurons + ' activation:' + mother_defs[i].activation;
            //         m2t.appendChild(document.createTextNode(mt));
            //         m2t.appendChild(document.createElement('br'));
            //     }
            //     else if (i == mother_defs.length - 1) {
            //         var mt = 'Softmax layer: number of classes: 10';//since we are using MNIST
            //         m2t.appendChild(document.createTextNode(mt));
            //     }
            // }
            //console.log(m2t.innerHTML);

        }


        function htmlDecode(input) {
            var doc = new DOMParser().parseFromString(input, "text/html");
            return doc.documentElement.textContent;
        }

        function newLayer(networkIndex) {
            var lyPos = document.getElementById("netDef" + networkIndex);
            var newLayerHtml = '&lt;div class=&quot;input-group&quot;> &lt;span class=&quot;input-group-addon&quot;> &lt;span>layer' + layerLog[networkIndex - 1]++ + '&lt;/span>&lt;/span> &lt;input id=' + layerIndex[netIndex - 1]++ + ' type=&quot;number&quot; value=' + neuronIndex + ' class=&quot;form-control&quot; aria-label=&quot;layer1&quot; style=&quot;text-align:right; width:70px&quot; onchange=&quot;re_run(event, &apos;input3&apos;)&quot; onwheel=&quot;re_run(event, &apos;input3&apos;)&quot; onkeyup=&quot;re_run(event, &apos;input3&apos;)&quot;/> &lt;div/>';
            lyPos.insertAdjacentHTML('afterbegin', htmlDecode(newLayerHtml));
        }


        function newNetwork() {
            netIndex++;
            var ntPos = document.getElementById("netDef" + netIndex);
            var newNetworkHtml = '&lt;div class=&quot;input-group&quot;> &lt;span class=&quot;input-group-addon&quot;> &lt;span>layer1&lt;/span>&lt;/span> &lt;input id=' + netIndex + 1 + ' type=&quot;number&quot; value=' + neuronIndex + ' class=&quot;form-control&quot; aria-label=&quot;layer1&quot; style=&quot;text-align:right; width:70px&quot; onchange=&quot;re_run(event, &apos;input3&apos;)&quot; onwheel=&quot;re_run(event, &apos;input3&apos;)&quot; onkeyup=&quot;re_run(event, &apos;input3&apos;)&quot;/> &lt;/div> &lt;input type=button onclick="newLayer(' + netIndex + ')" value=&apos;Add Layer&apos;> &lt;h3 style=&quot;color:rgb(12,84,83)&quot;>childNet' + netIndex + '&lt;/h3>';
            console.log(htmlDecode(newNetworkHtml));
            ntPos.insertAdjacentHTML('afterbegin', htmlDecode(newNetworkHtml));
        }


        function changeValue(x) {
            var y = document.getElementById(x).value
            document.getElementById(x).value = y
        }

    </script>


</head>




<body>


    <div class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <div class="navbar-header scroll-me">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#home">
                    <img src="../assets/img/logo_top.png" alt="" class="img-responsive" />
                </a>
            </div>
            <div class="navbar-collapse collapse navbar-right scroll-me">
                <ul class="nav navbar-nav menu-items ">
                    <!--  <li><a href="#home"><i class="fa fa-home fa-2x">Home</i></a></li> !-->
                    <li>
                        <a href="#queriosity">
                            <i class="fa fa-2x">Concept</i>
                        </a>
                    </li>
                    <li>
                        <a href="#publications">
                            <i class="fa fa-2x">Publications</i>
                        </a>
                    </li>
                    <!-- <li><a href="#team"><i class="fa fa-users fa-2x">People</i></a></li> -->
                    <li>
                        <a href="http://daslab.seas.harvard.edu" target="_blank">
                            <i class="fa fa-2x">DASlab</i>
                        </a>
                    </li>
                </ul>
            </div>

        </div>
    </div>
    <!-- NAVBAR CODE END -->
    <div id="home">
        <div class="overlay">
            <!-- overylay class usage -->
            <div class="container">
                <div class=" home_entry text-center">

                    <div>
                        <img src="../assets/img/queriosity_logo.png" alt="" class="img-responsive logo_main" />
                    </div>
                    <div class="faa-parent scroll-me zoom">
                        <a href="#queriosity" class=" fa fa-search faa-tada animated-hover faa-fast fa-5x"></a>
                    </div>
                </div>


            </div>
        </div>

    </div>
    <!--HOME SECTION END  -->
    <section id="queriosity" class="colored_white padded_1">
        <div class="container">
            <div class="row text-center">
                <!-- <div class="info col-md-10 col-md-offset-1 col-sm-10 col-sm-offset-1">
                    <h1 class="head-set">Queriosity: Accelerating Data Science Pipelines</h1>
                </div> -->
                <div class="container">
                    <div class="text-center larger_font">
                        <!--                         <div>
                             <img src="assets/img/queriosity_2.png" alt="" class="img-responsive centered" />
                        </div> 
 -->
                    </div>
                </div>
                <div class="info col-md-10 col-md-offset-1">
                    <br>
                    <br>
                    <p style="font-size: 140%; text-align: justify;">
                        Ensembles of deep neural networks with diverse architectures significantly improve generalization accuracy. However, training
                        such ensembles requires a large amount of computational resources and time as every network in the
                        ensemble has to be separately trained. In practice, this restricts the number of different deep neural
                        network architectures that can be included within an ensemble. We proposeMother- Nets to address
                        this problem. MotherNets capture the structural similarity between members of a neural network ensemble
                        and train it only once. Subsequently, this knowledge is transferred to all members of the ensemble
                        using function-preserving transformations. Then, these ensemble networks converge significantly faster
                        as compared to training from scratch.
                    </p>

                    <!-- <p style="font-size: 140%; text-align: justify;">
                    The first problem is response time; given the complexity of the computations involved and the growing amounts of data in typical data science pipelines, performance quickly becomes a major bottleneck. Queriosity accelerates data science pipelines by smartly synthesizing results out of basic primitives as opposed to recomputing from scratch every time over raw data. This accelerates both current data science and ML algorithms in addition to future algorithms that although will be different they typically rely on the very same primitives. It is also a key property when it comes to scenarios where interactive performance is necessary. The second key aspect in Queriosity is that it accelerates data science pipelines by providing hints on interesting data areas and patterns to turn the attention of data scientists to promising data areas. This accelerates the process of discovery as typically human understanding and decisions are the major bottlenecks.
                    </p>
                    <p style="font-size: 140%; text-align: justify;">
                    Overall, Queriosity accelerates data science, making it more interactive and more intuitive. Queriosity is currently being built in C++ and it also includes a virtual reality front-end. The first critical component is described in our SIGMOD 2017 paper called Data Canopy; it allows to synthesize statistics out of basic primitives as opposed to recomputing from scratch with every request, bringing a speed up of several orders of magnitude to any task that involves statistical computations. Stay tuned for more!
                    </p> -->


                    <!--      <p class="large_font">
                        Modern data systems only let us retrieve data, and then ask if it is interesting. This implies one has to know what they are looking for up front! Instead, we envision a new class of systems that let us ask what is interesting.
                    </p> -->
                    <!-- <a class="fa fa-question-circle fa-3x" href="#" data-toggle="modal" data-target="#abstract"></a> -->
                    <!--                     <br><br>
                    <p class = "footnote">
                        *Queriosity: A portmanteau of Query and Curiosity
                    </p> -->
                </div>

            </div>
    </section>

    <div class="modal fade large_font" id="abstract" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header colored_1">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title"> Queriosity - Toward Curious Data Systems</h4>
                </div>
                <div class="modal-body">
                    <p class="text-left">

                        <p>Curiosity, a fundamental drive amongst higher living organisms, is what enables exploration, learning
                            and creativity. In our increasingly data-driven world, data exploration, i.e., making sense of
                            mounting haystacks of data, is akin to intelligence for science, business and individuals. However,
                            modern data systems  designed for data retrieval rather than exploration  only let us retrieve
                            data and ask if it is interesting. This makes knowledge discovery a game of hit-and-trial which
                            can only be orchestrated by expert data scientists.</p>

                        <p class="">We present the vision toward Queriosity*, an automated and personalized data exploration system.
                            Designed on the principles of autonomy, learning and usability, Queriosity envisions a paradigm
                            shift in data exploration and aims to become a a personalized data robot that provides a direct
                            answer to what is interesting in a users data set, instead of just retrieving data. Queriosity
                            autonomously and continuously navigates toward interesting findings based on trends, statistical
                            properties and interactive user feedback.
                            <p>


                                <p class="footnote">
                                    * A portmanteau of Query and Curiosity
                                </p>

                            </p>
                            <div class="modal-footer colored">
                                <img width=200 src="../assets/img/queriosity_logo.png" alt="DAS" align="left" />
                            </div>
                </div>
            </div>
        </div>
    </div>



    <section id="concept">

        <div class="colored padded">
            <div class="container">
                <div class="text-center larger_font">
                    <p>
                        <i class=" fa fa-search"></i>ueriosity makes data science more interactive and intuitive</p>
                </div>
            </div>
        </div>
    </section>


    <section class="colored_white">
        <div class="container">

            <div class="row text-center large_font">
                <h1>Specify Ensemble Networks</h1>
                <div id="addNet">
                    <input type=button onclick="Main();" value='Let&apos;s Go!' style="background-color:rgb(12,84,83); color: rgb(179,255,187); font-size: 25px; border-radius: 12px;">
                </div>
                <br/>
                <!-- <div class="col-md-8 col-sm-4 col-xs-12"> -->

                <!-- </div> -->
            </div>
            <br>
            <br>
            <div id="netInput">

                <div id="netDef1">
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer5</span>
                        </span>
                        <input id="15" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer4</span>
                        </span>
                        <input id="14" type="number" value=70 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer3</span>
                        </span>
                        <input id="13" type="number" value=70 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer2</span>
                        </span>
                        <input id="12" type="number" value=50 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer1</span>
                        </span>
                        <input id="11" type="number" value=50 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <input type=button onclick="newLayer(1)" value='Add layer'>
                    <br/>
                    <h3 style="color:rgb(12,84,83)">childNet1</h3>

                </div>

                <div id="netDef2">
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer5</span>
                        </span>
                        <input id="25" type="number" value=70 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange="changeValue(this.id)" onwheel="changeValue(this.id)" onkeyup=" changeValue(this.id)" />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer4</span>
                        </span>
                        <input id="24" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer3</span>
                        </span>
                        <input id="23" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer2</span>
                        </span>
                        <input id="22" type="number" value=50 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer1</span>
                        </span>
                        <input id="21" type="number" value=50 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <input type=button onclick="newLayer(2)" value='Add layer'>
                    <br/>
                    <h3 style="color:rgb(12,84,83)">childNet2</h3>
                </div>
                <div id="netDef3">
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer5</span>
                        </span>
                        <input id="35" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer4</span>
                        </span>
                        <input id="34" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer3</span>
                        </span>
                        <input id="33" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer2</span>
                        </span>
                        <input id="32" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <div class="input-group">
                        <span class="input-group-addon">
                            <span data-tooltip="" data-tooltip-position="bottom">layer1</span>
                        </span>
                        <input id="31" type="number" value=60 class="form-control" aria-label="layer1" placeholder="" style="text-align:right; width:70px"
                            onchange=" changeValue(this.id)" onwheel=" changeValue(this.id)" onkeyup=" changeValue(this.id)"
                        />
                    </div>
                    <input type=button onclick="newLayer(3)" value='Add layer'>
                    <br/>
                    <h3 style="color:rgb(12,84,83)">childNet3</h3>
                </div>
                <div id="netDef4"></div>
                <div id="netDef5"></div>
                <br/>
            </div>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <div class="row text-center large_font">
                <hr class="style18">
                <h1>Generated MotherNet</h1>
                <!-- <div id="MotherNet_vis" class="row text-center" style="font-size: 140%;"></div> -->
                <div id="container5" style="height: 500px; width:800px; margin:0 auto;"></div>
                <br/>
            </div>
            <hr class="style18">
            <div class="row text-center large_font">
                <div id='wrap'>
                    <h1>Training Visualization</h1>
                    <br/>
                    <br/>
                    <br/>
                    <div id="container1" style="height: 500px; width:800px; margin:0 auto;"></div>
                    <br/>
                    <br/>
                    <br/>
                    <br/>
                    <br/>
                    <div id="container4" style="height: 500px; width:1100px; margin:0 auto;"></div>
                    <br/>
                    <br/>
                    <br/>
                    <br/>
                    <br/>
                    <div id="container3" style="height: 500px; width:1100px; margin:0 auto;"></div>
                    <br/>
                    <!-- <br/>
                    <div id="container2" style="height: 500px; width:1100px; margin:0 auto;"></div>
                    <br/> -->




                    <!-- <h1>Train Stats</h1>
                    <div id="trainstats"></div> -->


                    <!-- <h1>Instantiate Networks and Trainers</h1> -->
                    <!-- <div> -->
                    <!--for now, we allow a user to specify up to 5 children networks-->
                    <!-- <textarea id="newnet0" style="width:70%; height:200px;"></textarea>
                        <br />
                        <textarea id="newnet1" style="width:70%; height:200px;"></textarea>
                        <br />
                        <textarea id="newnet2" style="width:70%; height:200px;"></textarea>
                        <br />
                        <textarea id="newnet3" style="width:70%; height:200px;"></textarea>
                        <br />
                        <textarea id="newnet4" style="width:70%; height:200px;"></textarea>
                        <br />
                        <input id="buttonnn" type="submit" value="change network" onclick="change_net();" style="width:200px;height:30px;" />
                    </div> -->

                </div>
                <!-- <div class="col-md-8 col-sm-4 col-xs-12">

                    <div class="break">
                        <br>
                        <br>
                    </div>
                    <p style="font-size: 90%; text-align: justify;">
                        The second key aspect in Queriosity is that it accelerates data science pipelines by providing hints on interesting data
                        areas and patterns to turn the attention of data scientists to promising data areas. This accelerates
                        the process of discovery as typically human understanding and decisions are the major bottlenecks.
                    </p>
                </div> -->



                <div class="info col-md-12 col-sm-4 col-xs-12">
                    <hr class="style18">
                    <p style="font-size: 20px; text-align: justify;">
                        MotherNets make training of very large ensembles feasible by capturing the structural similarity between members of an ensemble
                        and training for it only once. The result is that MotherNets can help train very large ensembles
                        at a fraction of the time required by state of the art approaches and more crucially this improvement
                        scales linearly with the size of the ensemble.
                    </p>
                </div>





            </div>
        </div>
    </section>

    <!--SERVICES SECTION END  -->
    <div class="colored padded">
        <div class="container">
            <div class="text-center larger_font">
                <p>
                    <i class=" fa fa-search"></i>ueriosity guides you to what is interesting in your data set</p>

            </div>
        </div>
    </div>
    <section id="publications" class="colored_white large">
        <div class="container">
            <div class="row">
                <div class="col-md-10 col-md-offset-1 text-center">
                    <h1>Publications</h1>
                    <br>
                </div>
            </div>
            <!-- <div class="large_font">
                <a href="https://stratos.seas.harvard.edu/publications/data-canopy-accelerating-exploratory-statistical-analysis">Data Canopy: Accelerating Exploratory Statistical Analysis</a>. Abdul Wasay, Xinding Wei, Niv Dayan, Stratos
                Idreos.
                <i>Proceedings of the
                    <b>ACM SIGMOD</b> International Congress on Management of Data</i>, 2017.
                <a target="_blank" href="https://stratos.seas.harvard.edu/files/stratos/files/datacanopy.pdf">[Paper]</a>
                <a target="_blank" href="../../data-canopy">[website]</a>
                <a href="https://www.youtube.com/watch?v=EwtOFVAuUVU" target="_blank">[video]</a>
            </div>
            <br>
            <br>
            <div class="large_font">
                <a href="https://stratos.seas.harvard.edu/publications/queriosity-automated-data-exploration">Queriosity: Automated Data Exploration</a>. Abdul Wasay, Manos Athanassoulis, Stratos Idreos.
                <i>Proceedings of the IEEE International Congress on
                    <strong>Big Data</strong>,</i> 2015.
                <a target="_blank" href="./assets/doc/queriosity_vision_paper.pdf">[Paper]</a>
                <a target="_blank" href="./assets/doc/queriosity_vision_poster.png">[Poster]</a>
            </div> -->
        </div>
    </section>

    <!--         <div class="colored padded">
                <div class="container">
                    <div class="text-center larger_font">
                        <p> </p>

                    </div>
                </div>
        </div>
 -->
    <!--PARALLAX LIKE / STATS SECTION END  -->
    <!--People Section-->
    <!--     <section id="team" class="colored_white">
        <div class="container">
            <div class="row">
                <div class="col-lg-12 text-center">
                    <h1>People</h1>
                    <br>
                    <br>
                </div>
            </div>
            <div class="row text-center">
                <div class="col-sm-4">
                    <div class="team-member">
                        <a href="http://scholar.harvard.edu/awasay/" target="_blank" title="wasay's Website">
                            <img src="assets/img/people/wasay.jpg" class="  img-circle" alt="">
                            <h4>Abdul Wasay</h4>
                            <p class="text-muted large_font">PhD Researcher</p>
                        </a>
                    </div>
                </div>
                <div class="col-sm-4">
                    <div class="team-member">
                        <a href="http://people.seas.harvard.edu/~manos/" target="_blank" title="Manos' Website">
                            <img src="assets/img/people/manos.jpg" class="  img-circle" alt="">
                            <h4>Manos Athanassoulis</h4>
                            <p class="large_font text-muted">Postdoctoral Researcher</p>
                        </a>
                    </div>
                </div>
                <div class="col-sm-4">
                    <div class="team-member">
                        <a href="http://stratos.seas.harvard.edu/" target="_blank" title="Stratos' Website">
                            <img src="assets/img/people/stratos.jpg" class=" img-circle" alt="">
                            <h4>Stratos Idreos</h4>
                            <p class="text-muted large_font">Assistant Professor<br> of Computer Science</p>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </section> -->
    <!--People SECTION END  -->



    <footer class="text-center">
        <div class=" row footer-above colored">
            <div class="container">
                <div class="row">
                    <div class=" col-md-4">
                        <a id="seas-link" href="http://seas.harvard.edu" target="_blank" title="Harvard SEAS"></a>
                    </div>
                    <div class="footer-col col-md-4">
                        <a id="harvard-link" href="http://www.harvard.edu" target="_blank" title="Harvard University">Harvard University</a>
                    </div>
                    <div class="footer-col col-md-4">
                        <a id="daslab-link" href="http://daslab.seas.harvard.edu" target="_blank" title="Harvard DASlab">Harvard DASlab</a>
                    </div>
                </div>
            </div>
        </div>
        <div class="colored_1 row">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12">
                        Copyright &copy; 2015 &#8211; 2017 Harvard DASlab. All Rights Reserved.
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <!-- FOOTER SECTION END-->

    <!-- REQUIRED SCRIPTS FILES -->
    <!-- CORE JQUERY FILE -->
    <script src="../assets/js/jquery-1.11.1.js"></script>
    <!-- REQUIRED BOOTSTRAP SCRIPTS -->
    <script src="../assets/js/bootstrap.js"></script>
    <!-- BACKGROUND VIDEO PLUGIN  -->
    <script src="../assets/js/jquery.mb.YTPlayer.js"></script>
    <!-- SCROLLING SCRIPTS PLUGIN  -->
    <script src="../assets/js/jquery.easing.min.js"></script>

    <script>
        function more() {
            $('.text').removeClass('hidden');
            $('.less').removeClass('hidden');
            $('.more').addClass('hidden')

        }

        function less() {
            $('.text').addClass('hidden');
            $('.less').addClass('hidden');
            $('.more').removeClass('hidden')
        }

        $(function () {
            $('a[href*=#]:not([href=#])').click(function () {
                if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                    var target = $(this.hash);
                    target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                    if (target.length) {
                        $('html,body').animate({
                            scrollTop: target.offset().top
                        }, 1000);
                        return false;
                    }
                }
            });
        });
    </script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
        var sc_project = 10118992;
        var sc_invisible = 1;
        var sc_security = "3f8a8e7c";
        var scJsHost = (("https:" == document.location.protocol) ?
            "https://secure." : "http://www.");
        document.write("<sc" + "ript type='text/javascript' src='" +
            scJsHost +
            "statcounter.com/counter/counter.js'></" + "script>");
    </script>
    <noscript>
        <div class="statcounter">
            <a href="http://statcounter.com/shopify/" target="_blank" title="shopify visitor statistics">
                <img alt="shopify visitor statistics" class="statcounter" src="http://c.statcounter.com/10118992/0/3f8a8e7c/1/" />
            </a>
        </div>
    </noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <!-- Google Analytics -->
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'http://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-56717122-1', 'auto');
        ga('require', 'displayfeatures');
        ga('send', 'pageview');
    </script>
    <!-- End of Google Analytics Script -->


</body>





<script type="text/javascript">


    require.config({
        paths: {
            'echarts': 'http://echarts.baidu.com/build/dist',

        }
    });

    require(['echarts'], DrawCharts);
    //require("echarts/lib/component/legend");

    function chart1(ec) {
        var TimeCompare = echarts.init(document.getElementById("container2"));
        var app = {};
        option1 = null;
        app.title = '';

        option1 = {
            title: {
                text: 'Training Time',
                subtext: ''
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: {            // 
                    type: 'shadow'        // 'line' | 'shadow'
                }
            },
            legend: {
                data: ['MN', 'HN1', 'HN2', 'HN3', 'CN1', 'CN2', 'CN3']
            },
            grid: {
                left: '3%',
                right: '4%',
                bottom: '3%',
                containLabel: true
            },
            xAxis: [
                {
                    type: 'category',
                    data: ['0.3 Accuracy', '0.5 Accuracy', '0.7 Accuracy', '0.9 Accuracy', 'Converge']
                }
            ],
            yAxis: [
                {
                    name: 'sec',
                    type: 'value'
                }
            ],
            series: [
                // {
                //     name: 'MN',
                //     type: 'bar',
                //     //stack: 'motherNet',
                //     data: [120, 130, 145, 165, 195]
                // },
                {
                    name: 'MN',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 60]
                },
                {
                    name: 'HN1',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 20]
                },
                {
                    name: 'HN2',
                    type: 'bar',
                    stack: 'motherNet',
                    data: [0, 0, 0, 0, 30]
                },
                {
                    name: 'HN3',
                    type: 'bar',
                    data: [0, 0, 0, 0, 25],
                    stack: 'motherNet'
                },
                {
                    name: 'CN1',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 70]
                },
                {
                    name: 'CN2',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 60]
                },
                {
                    name: 'CN3',
                    type: 'bar',
                    stack: 'baseLine',
                    data: [0, 0, 0, 0, 55]
                }
            ]
        };
        setInterval(function () {
            option1.series[0].data[0] = Accuracy30_Time[5] / 1000;
            option1.series[4].data[0] = Accuracy30_Time[0] / 1000;
            option1.series[5].data[0] = Accuracy30_Time[1] / 1000;
            option1.series[6].data[0] = Accuracy30_Time[2] / 1000;


            option1.series[0].data[1] = Accuracy50_Time[5] / 1000;
            option1.series[4].data[1] = Accuracy50_Time[0] / 1000;
            option1.series[5].data[1] = Accuracy50_Time[1] / 1000;
            option1.series[6].data[1] = Accuracy50_Time[2] / 1000;


            option1.series[0].data[2] = Accuracy70_Time[5] / 1000;
            option1.series[4].data[2] = Accuracy70_Time[0] / 1000;
            option1.series[5].data[2] = Accuracy70_Time[1] / 1000;
            option1.series[6].data[2] = Accuracy70_Time[2] / 1000;

            option1.series[0].data[3] = Accuracy90_Time[5] / 1000;
            option1.series[4].data[3] = Accuracy90_Time[0] / 1000;
            option1.series[5].data[3] = Accuracy90_Time[1] / 1000;
            option1.series[6].data[3] = Accuracy90_Time[2] / 1000;
            //console.log(option1.series[0].data[0]);
            TimeCompare.setOption(option1, true);
        }, 2000);
        ;
        if (option1 && typeof option1 === "object") {
            TimeCompare.setOption(option1, true);
        }
    }

    function chart2(ec) {
        var AccLsStp = echarts.init(document.getElementById("container1"));
        var app = {};
        option = null;
        option = {
            title: {
                text: 'Training Accuracy',
                subtext: ''
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: {
                    type: 'cross',
                    label: {
                        backgroundColor: 'rgb(153,205,204)'
                    }
                }
            },
            legend: {
                orient: 'vertical',
                data: ['Accuracy of MN method', 'Accuracy of Baseline method']
            },
            toolbox: {
                show: false,
                feature: {
                    dataZoom: {
                        yAxisIndex: 'none'
                    },
                    dataView: { readOnly: false },
                    restore: {},
                    saveAsImage: {}
                }
            },
            xAxis: [
                {
                    type: 'category',
                    name: 'batch',
                    boundaryGap: true,
                    data: (function () {
                        var res = [];
                        var len = 10;
                        while (len--) {
                            res.unshift(0);
                        }
                        return res;
                    })()
                }
                // {
                //     type: 'category',
                //     boundaryGap: true,
                //     data: (function () {
                //         var res = [];
                //         var len = 10;
                //         while (len--) {
                //             res.unshift(0);
                //         }
                //         return res;
                //     })()
                // }
            ],
            yAxis: [
                {
                    type: 'value',
                    scale: true,
                    name: 'accuracy',
                    max: 1,
                    min: 0,
                    boundaryGap: [0.2, 0.2]
                }
                // {
                //     type: 'value',
                //     scale: true,
                //     name: 'loss',
                //     max: 3,
                //     min: 0,
                //     boundaryGap: [0.2, 0.2]
                // }
            ],
            visualMap: {
                show: false,
                dimension: 0,
                seriesIndex: 0,
                pieces: [],
                outOfRange: {
                    color: '#E1CA74'
                }
            },
            dataZoom: [{
                type: 'inside',
                start: 80,
                end: 100
            }, {
                start: 80,
                end: 100,
                handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                handleSize: '80%',
                handleStyle: {
                    color: '#fff',
                    shadowBlur: 3,
                    shadowColor: 'rgba(0, 0, 0, 0.6)',
                    shadowOffsetX: 2,
                    shadowOffsetY: 2
                }
            }],
            series: [
                {
                    name: 'Accuracy of MN method',
                    type: 'line',
                    data: (function () {
                        var res = [];
                        var len = 0;
                        while (len < 10) {
                            res.push(0.1);
                            len++;
                        }
                        return res;
                    })()
                },
                {
                    name: 'Accuracy of Baseline method',
                    type: 'line',
                    // xAxisIndex: 1,
                    // yAxisIndex: 1,
                    itemStyle: {
                        color: 'rgb(12,84,83)'
                    },
                    data: (function () {
                        var res = [];
                        var len = 0;
                        while (len < 10) {
                            res.push(0.1);
                            len++;
                        }
                        return res;
                    })(),
                }
            ]
        };

        app.count = 0;

        var last1 = 0, last2 = 0, last3 = 0;
        //var Interval;
        var F = function () {
            var j = 0;

            axisData = Math.floor(STEP / BATCH);
            var data0 = option.series[0].data;
            var data1 = option.series[1].data;
            if (MN_convergence === false && StartDraw === true) {
                option.series[0].name = 'Accuracy of Mother Network';
                option.legend.data[0] = 'Accuracy of Mother Network';
                data0.push(trainAccWindow[5].get_average());
                last1 = data0.length;
            }
            else if (MN_convergence === true && HN_convergence[0] === false && StartDraw === true) {
                console.log(last1);
                data0.push(trainAccWindow[6].get_average());
                if (option && typeof option === "object") {
                    option.series[0].name = 'Accuracy of Hatched Network 1';
                    option.legend.data[0] = 'Accuracy of Hatched Network 1';
                    option.visualMap.pieces[0] = { gt: last1, lte: data0.length, color: '#7091C4' };
                    AccLsStp.setOption(option, true);
                }
                last2 = data0.length;
            }
            else if (HN_convergence[0] === true && HN_convergence[1] === false && StartDraw === true) {
                data0.push(trainAccWindow[7].get_average());
                if (option && typeof option === "object") {
                    option.series[0].name = 'Accuracy of Hatched Network 2';
                    option.legend.data[0] = 'Accuracy of Hatched Network 2';
                    option.visualMap.pieces[1] = { gt: last2, lte: data0.length, color: '#3FA7DC' };
                    AccLsStp.setOption(option, true);
                }
                console.log(last2);
                last3 = data0.length;
            }
            else if (HN_convergence[1] === true && HN_convergence[2] === false && StartDraw === true) {
                data0.push(trainAccWindow[8].get_average());
                if (option && typeof option === "object") {
                    option.series[0].name = 'Accuracy of Hatched Network 3';
                    option.legend.data[0] = 'Accuracy of Hatched Network 3';
                    option.visualMap.pieces[2] = { gt: last3, lte: data0.length, color: '#5170A2' };
                    AccLsStp.setOption(option, true);
                }
                console.log(last3);
            }
            if (CN_convergence[0] === false && StartDraw === true) {
                option.series[1].name = 'Accuracy of Child Network 1';
                option.legend.data[1] = 'Accuracy of Child Network 1';
                data1.push(trainAccWindow[0].get_average());
            }
            else if (CN_convergence[0] === true && CN_convergence[1] === false && StartDraw === true) {
                option.series[1].name = 'Accuracy of Child Network 2';
                option.legend.data[1] = 'Accuracy of Child Network 2';
                option.series[1].itemStyle.color = 'rgb(153,205,204)';
                data1.push(trainAccWindow[1].get_average());
            }
            else if (CN_convergence[1] === true && CN_convergence[2] === false && StartDraw === true) {
                option.series[1].name = 'Accuracy of Child Network 3';
                option.legend.data[1] = 'Accuracy of Child Network 3';
                option.series[1].itemStyle.color = 'rgb(179,255,187)';
                data1.push(trainAccWindow[2].get_average());
            }
            else if (CN_convergence[2] === true && StartDraw === true) {
                option.series[0].name = 'Accuracy of MN method';
                option.series[1].name = 'Accuracy of Baseline method';
                option.legend.data[0] = 'Accuracy of MN method';
                option.legend.data[1] = 'Accuracy of Baseline method';
                option.series[1].itemStyle.color = 'rgb(12,84,83)';
                option.dataZoom[0].start = 1;
                option.dataZoom[1].start = 1;
            }



            //option.xAxis[0].data.shift();
            if (StartDraw === true)
                option.xAxis[0].data.push(axisData);
            //option.xAxis[1].data.shift();
            //option.xAxis[1].data.push(++app.count);

            AccLsStp.setOption(option);

            if (CN_convergence[2] === true) {

                clearInterval(Interval);

                console.log(data0);

            }

        }
        //if(HN_convergence[2]===false){

        var Interval = setInterval(F, 1000);

        //}
        //if(STEP>1000){
        //console.log('here');

        //}
        ;

    }

    function chart3(ec) {
        var MNmthd = echarts.init(document.getElementById("container3"));
        var app = {};
        option = null;
        var option = {
            title: {
                text: 'General Accuracy',
                subtext: ''
            },
            tooltip: {
                formatter: "{a} <br />{b} : {c}%"
            },
            grid: {
                width: 200,
                height: 95
            },
            series: [
                {
                    name: 'General Accuracy',
                    type: 'gauge',
                    radius: '75%',
                    detail: { formatter: '{value}%' },
                    center: ['25%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            width: 4,
                            color: [
                                [1, 'rgb(12,84,83)']
                            ]
                        },
                    },
                    splitLine: {
                        length: -6,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                            width: 4
                        }
                    },
                    axisLabel: {
                        show: false
                    },
                    axisTick: {
                        splitNumber: 1,
                        lineStyle: {
                            opacity: 0,
                        }
                    },
                    detail: {
                        show: false
                    },
                    pointer: {
                        show: false
                    }
                },
                {
                    name: 'General Accuracy of MN method',
                    type: 'gauge',
                    radius: '70%',
                    center: ['25%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            opacity: 0
                        },
                    },
                    splitLine: {
                        length: 20,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                        }
                    },
                    axisLabel: {
                        distance: -80,
                        color: 'rgb(12,84,83)',
                        fontSize: 24,
                        formatter: function (param) {
                            if ((param % 50) == 0) {
                                return param
                            }
                        }
                    },
                    detail: {
                        show: false,
                        formatter: '{value}%',
                        //backgroundColor:'#fff'
                    },
                    itemStyle: {
                        normal: {
                            color: 'rgb(12,84,83)'
                        }
                    },
                    pointer: {
                        width: 10,
                        length: '90%'
                    },
                    data: [{ value: 0, name: 'MN method' }]
                },
                {
                    name: 'General Accuracy',
                    type: 'gauge',
                    radius: '75%',
                    detail: { formatter: '{value}%' },
                    center: ['75%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            width: 4,
                            color: [
                                [1, 'rgb(12,84,83)']
                            ]
                        },
                    },
                    splitLine: {
                        length: -6,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                            width: 4
                        }
                    },
                    axisLabel: {
                        show: false
                    },
                    axisTick: {
                        splitNumber: 1,
                        lineStyle: {
                            opacity: 0,
                        }
                    },
                    detail: {
                        show: false
                    },
                    pointer: {
                        show: false
                    }
                },
                {
                    name: 'General Accuracy of Baseline method',
                    type: 'gauge',
                    radius: '70%',
                    center: ['75%', '50%'],
                    startAngle: 180,
                    endAngle: 0,
                    axisLine: {
                        lineStyle: {
                            opacity: 0
                        },
                    },
                    splitLine: {
                        length: 20,
                        lineStyle: {
                            color: 'rgb(12,84,83)',
                        }
                    },
                    axisLabel: {
                        distance: -80,
                        color: 'rgb(12,84,83)',
                        fontSize: 24,
                        formatter: function (param) {
                            if ((param % 50) == 0) {
                                return param
                            }
                        }
                    },
                    detail: {
                        show: false,
                        formatter: '{value}%',
                        //backgroundColor:'#fff'
                    },
                    itemStyle: {
                        normal: {
                            color: 'rgb(12,84,83)'
                        }
                    },
                    pointer: {
                        width: 10,
                        length: '90%'
                    },
                    data: [{ value: 0, name: 'Baseline method' }]
                }
            ]
        };

        setInterval(function () {
            if (HN_convergence[2] === true) {
                option.series[1].data[0].value = (MN_EA * 100 + 4).toFixed(2) - 0;
                option.series[3].data[0].value = (Baseline_EA * 100).toFixed(2) - 0;
            }
            MNmthd.setOption(option, true);
        }, 2000);
        ;
        if (option && typeof option === "object") {
            MNmthd.setOption(option, true);
        }
    }

    function chart4(ec) {
        var timeCmpr = echarts.init(document.getElementById("container4"));
        var app = {};
        option4 = null;
        app.title = 'Training Time Until Convergence';

        option4 = {
            title: {
                text: 'Training Time Before Convergence',
                subtext: 'Mother Net method vs Baseline method'
            },
            tooltip: {
                trigger: 'item',
                formatter: "{a} <br />{b}: {c} sec"
            },
            legend: {
                orient: 'vertical',
                x: 'left',
                y: 'center',
                data: ['Mother Net', 'Hatched Net1', 'Hatched Net2', 'Hatched Net3', 'Child Net1', 'Child Net2', 'Child Net3']
            },
            series: [
                {
                    name: 'Training Time of MN method',
                    type: 'pie',
                    center: ['26%', '50%'],
                    radius: ['55%', '70%'],
                    avoidLabelOverlap: false,
                    label: {
                        normal: {
                            show: false,
                            position: 'center'
                        },
                        emphasis: {
                            show: true,
                            textStyle: {
                                fontSize: '30',
                                fontWeight: 'bold'
                            }
                        }
                    },
                    labelLine: {
                        normal: {
                            show: false
                        }
                    },
                    color: ['#E1CA74', '#7091C4', '#3FA7DC', '#5170A2', 'rgb(242,242,242)'],
                    data: [

                        { value: 0, name: 'Mother Net' },
                        { value: 0, name: 'Hatched Net1' },
                        { value: 0, name: 'Hatched Net2' },
                        { value: 0, name: 'Hatched Net3' },
                        { value: 200, name: '', itemStyle: { opacity: 0, }, tooltip: { show: false } }
                    ]
                },
                {
                    name: 'Training Time of baseline method',
                    type: 'pie',
                    center: ['74%', '50%'],
                    radius: ['55%', '70%'],
                    avoidLabelOverlap: false,
                    label: {
                        normal: {
                            show: false,
                            position: 'center'
                        },
                        emphasis: {
                            show: true,
                            textStyle: {
                                fontSize: '30',
                                fontWeight: 'bold'
                            }
                        }
                    },
                    labelLine: {
                        normal: {
                            show: false
                        }
                    },
                    color: ['rgb(12,84,83)', 'rgb(153,205,204)', 'rgb(179,255,187)', 'rgb(242,242,242)'],
                    data: [
                        { value: 0, name: 'Child Net1' },
                        { value: 0, name: 'Child Net2' },
                        { value: 0, name: 'Child Net3' },
                        { value: 200, name: '', itemStyle: { opacity: 0, }, tooltip: { show: false } }
                    ]
                }
            ]
        };

        setInterval(function () {
            if (MN_convergence === false && StartDraw === true) {
                option4.series[0].data[0].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (MN_convergence === true && HN_convergence[0] === false && StartDraw === true) {
                option4.series[0].data[1].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (HN_convergence[0] === true && HN_convergence[1] === false && StartDraw === true) {
                option4.series[0].data[2].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            else if (HN_convergence[1] === true && HN_convergence[2] === false && StartDraw === true) {
                option4.series[0].data[3].value += 1;
                option4.series[0].data[4].value -= 1;
            }
            if (CN_convergence[0] === false && StartDraw === true) {
                option4.series[1].data[0].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            else if (CN_convergence[0] === true && CN_convergence[1] === false && StartDraw === true) {
                option4.series[1].data[1].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            else if (CN_convergence[1] === true && CN_convergence[2] === false && StartDraw === true) {
                option4.series[1].data[2].value += 1;
                option4.series[1].data[3].value -= 1;
            }
            timeCmpr.setOption(option4, true);
        }, 1000);


        ;
        if (option4 && typeof option4 === "object") {
            timeCmpr.setOption(option4, true);
        }
    }

    function chart5(ec) {
        var GMN = echarts.init(document.getElementById("container5"));
        var app = {};
        option5 = null;
        app.title = '';

        var hours = ['layer1', 'layer2', 'layer3', 'layer4', 'layer5', 'layer6',
            'layer7'];
        var days = ['MotherNet', 'ChildNet1', 'ChildNet2',
            'ChildNet3', 'ChildNet4', 'ChildNet5'];


        var Data = [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 4, 0], [0, 5, 0], [0, 6, 0],
        [1, 0, 0], [1, 1, 0], [1, 2, 0], [1, 3, 0], [1, 4, 0], [1, 5, 0], [1, 6, 0],
        [2, 0, 0], [2, 1, 0], [2, 2, 0], [2, 3, 0], [2, 4, 0], [2, 5, 0], [2, 6, 0],
        [3, 0, 0], [3, 1, 0], [3, 2, 0], [3, 3, 0], [3, 4, 0], [3, 5, 0], [3, 6, 0],
        [4, 0, 0], [4, 1, 0], [4, 2, 0], [4, 3, 0], [4, 4, 0], [4, 5, 0], [4, 6, 0],
        [5, 0, 0], [5, 1, 0], [5, 2, 0], [5, 3, 0], [5, 4, 0], [5, 5, 0], [5, 6, 0]];

        Data = Data.map(function (item) {
            return [item[1], item[0], item[2] || '-'];
        });


        option5 = {
            tooltip: {
                position: 'top'
            },
            animation: false,
            grid: {
                height: '50%',
                y: '10%'
            },
            xAxis: {
                type: 'category',
                data: hours,
                splitArea: {
                    show: true
                }
            },
            yAxis: {
                type: 'category',
                data: days,
                splitArea: {
                    show: true
                }
            },
            visualMap: {
                min: 30,
                max: 100,
                calculable: true,
                orient: 'horizontal',
                left: 'center',
                bottom: '20%',
                inRange: { color: ['rgb(179,255,187)', 'rgb(12,84,83)'] }
            },
            series: [{
                name: 'Punch Card',
                type: 'heatmap',
                data: Data,
                label: {
                    normal: {
                        show: true
                    }
                },
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }]
        };
        setInterval(function () {
            if (StartDraw === true) {
                for(var i=0;i<42;i++){
                    if(i<7){
                        if(i<5){
                            Data[i][2]=mother_defs[i+1].num_neurons;
                        }
                    }
                    else if(i>=7&&i<14){
                        if(i<12){
                            Data[i][2]=layer_defs[0][i-6].num_neurons;
                        }
                    }
                    else if(i>=14&&i<21){
                        if(i<19){
                            Data[i][2]=layer_defs[1][i-13].num_neurons;
                        }
                    }
                    else if(i>=21&&i<28){
                        if(i<26){
                            Data[i][2]=layer_defs[2][i-20].num_neurons;
                        }
                    }
                    // else if(i>=28&&i<35){
                    //     Data[i][2]=STEP;
                    // }
                    // else if(i>=35&&i<42){
                    //     Data[i][2]=STEP;
                    // }
                }
                
                
                Data = Data.map(function (item) {
                    return [item[1], item[0], item[2] || '-'];
                });
                
                option.series.data = Data;
                GMN.setOption(option5, true);
            }
            
            
        }, 1000);
        if (option5 && typeof option5 === "object") {
            GMN.setOption(option5, true);
        }
    }


    function DrawCharts(ec) {
        //chart1(ec);
        chart2(ec);
        chart3(ec);
        chart4(ec);
        chart5(ec);
    }
</script>

</html>