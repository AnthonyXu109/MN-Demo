<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="author" content="Chang">


    <script src="jquery-1.8.3.min.js"></script>
    <script src="../build/vis.js"></script>
    <script src="../build/util.js"></script>
    <script src="../build/convnet.js"></script>
    <script src="../demo/cifar10_labels.js"></script>

    <script>

        //it seems silly using array :( , let me replace them by an object later
        var layer_defs = new Array();
        var net = new Array();
        var trainer = new Array();
        var t = new Array();

        //I will take care of the training of mother network later. For now, just the building process.
        var mother_defs, motherNet;
        mother_defs = [];
        mother_defs.push({ type: 'input', out_sx: 32, out_sy: 32, out_depth: 3 });//the mother net needs an input layer by default



        //I wanna implement just two networks by default and allow users to change the number of children networks,
        //but there are still some bugs with the code. So for now, there are already five networks by defaualt, users
        //cannot change the number of networks but can change the details of them, like filter numbers of each net at each conv layer
        t[0] = "layer_defs[0] = [];\n\
        layer_defs[0].push({type:'input', out_sx:32, out_sy:32, out_depth:3});\n\
        layer_defs[0].push({type:'conv', sx:5, filters:16, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[0].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[0].push({type:'conv', sx:5, filters:10, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[0].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[0].push({type:'conv', sx:5, filters:5, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[0].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[0].push({type:'softmax', num_classes:10});\n\
        \n\
        net[0] = new convnetjs.Net();\n\
        net[0].makeLayers(layer_defs[0]);\n\
        \n\
        trainer[0] = new convnetjs.SGDTrainer(net[0], {method:'adadelta', batch_size:4, l2_decay:0.0001});\n\
        ";

        t[1] = "layer_defs[1] = [];\n\
        layer_defs[1].push({type:'input', out_sx:32, out_sy:32, out_depth:3});\n\
        layer_defs[1].push({type:'conv', sx:5, filters:10, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[1].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[1].push({type:'conv', sx:5, filters:20, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[1].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[1].push({type:'conv', sx:5, filters:6, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[1].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[1].push({type:'softmax', num_classes:10});\n\
        \n\
        net[1] = new convnetjs.Net();\n\
        net[1].makeLayers(layer_defs[1]);\n\
        \n\
        trainer[1] = new convnetjs.SGDTrainer(net[1], {method:'adadelta', batch_size:4, l2_decay:0.0001});\n\
        ";

        t[2] = "layer_defs[2] = [];\n\
        layer_defs[2].push({type:'input', out_sx:32, out_sy:32, out_depth:3});\n\
        layer_defs[2].push({type:'conv', sx:5, filters:9, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[2].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[2].push({type:'conv', sx:5, filters:15, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[2].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[2].push({type:'conv', sx:5, filters:7, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[2].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[2].push({type:'softmax', num_classes:10});\n\
        \n\
        net[2] = new convnetjs.Net();\n\
        net[2].makeLayers(layer_defs[2]);\n\
        \n\
        trainer[2] = new convnetjs.SGDTrainer(net[2], {method:'adadelta', batch_size:4, l2_decay:0.0001});\n\
        ";

        t[3] = "layer_defs[3] = [];\n\
        layer_defs[3].push({type:'input', out_sx:32, out_sy:32, out_depth:3});\n\
        layer_defs[3].push({type:'conv', sx:5, filters:8, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[3].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[3].push({type:'conv', sx:5, filters:15, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[3].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[3].push({type:'conv', sx:5, filters:8, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[3].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[3].push({type:'softmax', num_classes:10});\n\
        \n\
        net[3] = new convnetjs.Net();\n\
        net[3].makeLayers(layer_defs[3]);\n\
        \n\
        trainer[3] = new convnetjs.SGDTrainer(net[3], {method:'adadelta', batch_size:4, l2_decay:0.0001});\n\
        ";


        t[4] = "layer_defs[4] = [];\n\
        layer_defs[4].push({type:'input', out_sx:32, out_sy:32, out_depth:3});\n\
        layer_defs[4].push({type:'conv', sx:5, filters:7, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[4].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[4].push({type:'conv', sx:5, filters:20, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[4].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[4].push({type:'conv', sx:5, filters:9, stride:1, pad:2, activation:'relu'});\n\
        layer_defs[4].push({type:'pool', sx:2, stride:2});\n\
        layer_defs[4].push({type:'softmax', num_classes:10});\n\
        \n\
        net[4] = new convnetjs.Net();\n\
        net[4].makeLayers(layer_defs[4]);\n\
        \n\
        trainer[4] = new convnetjs.SGDTrainer(net[4], {method:'adadelta', batch_size:4, l2_decay:0.0001});\n\
        ";



        var step_num = 0;
        var maxmin = cnnutil.maxmin;
        var f2t = cnnutil.f2t;
        // ------------------------
        // BEGIN CIFAR10 SPECIFIC STUFF
        // ------------------------
        var classes_txt = ['airplane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'];

        var use_validation_data = true;

        var num_batches = 51; // 50 training batches, 1 test batch
        var test_batch = 50;
        var data_img_elts = new Array(num_batches);
        var img_data = new Array(num_batches);
        var loaded = new Array(num_batches);
        var loaded_train_batches = [];

        var sample_training_instance = function () {
            // find an unloaded batch
            var bi = Math.floor(Math.random() * loaded_train_batches.length);
            var b = loaded_train_batches[bi];
            var k = Math.floor(Math.random() * 1000); // sample within the batch
            var n = b * 1000 + k;

            // load more batches over time
            if (step_num % 2000 === 0 && step_num > 0) {
                for (var i = 0; i < num_batches; i++) {
                    if (!loaded[i]) {
                        load_data_batch(i);
                        break;
                    }
                }
            }

            // fetch the appropriate row of the training image and reshape into a Vol
            var p = img_data[b].data;
            var x = new convnetjs.Vol(32, 32, 3, 0.0);
            var W = 32 * 32;
            var j = 0;
            for (var dc = 0; dc < 3; dc++) {
                var i = 0;
                for (var xc = 0; xc < 32; xc++) {
                    for (var yc = 0; yc < 32; yc++) {
                        var ix = ((W * k) + i) * 4 + dc;
                        x.set(yc, xc, dc, p[ix] / 255.0 - 0.5);
                        i++;
                    }
                }
            }
            var dx = Math.floor(Math.random() * 5 - 2);
            var dy = Math.floor(Math.random() * 5 - 2);
            x = convnetjs.augment(x, 32, dx, dy, Math.random() < 0.5);

            var isval = use_validation_data && n % 10 === 0 ? true : false;
            return { x: x, label: labels[n], isval: isval };
        }

        // sample a random testing instance
        var sample_test_instance = function () {

            var b = test_batch;
            var k = Math.floor(Math.random() * 1000);
            var n = b * 1000 + k;

            var p = img_data[b].data;
            var x = new convnetjs.Vol(32, 32, 3, 0.0);
            var W = 32 * 32;
            var j = 0;
            for (var dc = 0; dc < 3; dc++) {
                var i = 0;
                for (var xc = 0; xc < 32; xc++) {
                    for (var yc = 0; yc < 32; yc++) {
                        var ix = ((W * k) + i) * 4 + dc;
                        x.set(yc, xc, dc, p[ix] / 255.0 - 0.5);
                        i++;
                    }
                }
            }

            // distort position and maybe flip
            var xs = [];
            //xs.push(x, 32, 0, 0, false); // push an un-augmented copy
            for (var k = 0; k < 6; k++) {
                var dx = Math.floor(Math.random() * 5 - 2);
                var dy = Math.floor(Math.random() * 5 - 2);
                xs.push(convnetjs.augment(x, 32, dx, dy, k > 2));
            }

            // return multiple augmentations, and we will average the network over them
            // to increase performance
            return { x: xs, label: labels[n] };
        }

        // int main
        $(window).load(function () {

            for (var i = 0; i < t.length; i++) {
                $("#newnet" + i).val(t[i]);
                eval($("#newnet" + i).val());
            }


            //we built mother network here based on layer definitions of each child network
            //we look at all the children networks at all convolutional layers (so we skip Input, pooling and softmax layers)
            //, and add the one with fewest filters into the mother network.
            ////loop for all positions but skip the input layer and softmax layer
            for (var i = 1; (i < layer_defs[0].length - 1) || (i < layer_defs[1].length - 1) || (i < layer_defs[2].length - 1) || (i < layer_defs[3].length - 1) || (i < layer_defs[4].length - 1); i += 2) {
                var temp_filterNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'conv' && layer_defs[j][i].filters < temp_filterNum && layer_defs[j][i].filters > 0) {
                        temp_filterNum = layer_defs[j][i].filters;
                    }
                }
                mother_defs.push({ type: 'conv', sx: 5, filters: temp_filterNum, stride: 1, pad: 2, activation: 'relu' });
                mother_defs.push({ type: 'pool', sx: 2, stride: 2 });//add a pooling layer after every conv layer by default
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it

            //for now, we show the motherNet by simply print each layer
            var m2t = document.getElementById("MotherNet_vis");
            m2t.innerHTML = '';
            for (var i = 0; mother_defs[i]; i++) {
                if (i == 0) {
                    var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'conv') {
                    var mt = 'Convolutional layer:' + ' sx:' + mother_defs[i].sx + ' filters:' + mother_defs[i].filters + ' stride:' + mother_defs[i].stride + ' pad:' + mother_defs[i].pad + ' activation:' + mother_defs[i].activation;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'pool') {
                    var mt = 'Pooling layer:' + ' sx:' + mother_defs[i].sx + ' stride:' + mother_defs[i].stride;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (i == mother_defs.length - 1) {
                    var mt = 'Softmax layer: number of classes: 10';//since we are using cifar10
                    m2t.appendChild(document.createTextNode(mt));
                }
            }



            for (var k = 0; k < loaded.length; k++) { loaded[k] = false; }

            load_data_batch(0); // async load train set batch 0 (6 total train batches)
            load_data_batch(test_batch); // async load test set (batch 6)
            start_fun();
        });

        var start_fun = function () {
            if (loaded[0] && loaded[test_batch]) {
                console.log('starting!');
                setInterval(load_and_step, 0);
            }
            else { setTimeout(start_fun, 200); } // keep checking
        }

        var load_data_batch = function (batch_num) {
            // Load the dataset with JS in background
            data_img_elts[batch_num] = new Image();
            var data_img_elt = data_img_elts[batch_num];
            data_img_elt.onload = function () {
                var data_canvas = document.createElement('canvas');
                data_canvas.width = data_img_elt.width;
                data_canvas.height = data_img_elt.height;
                var data_ctx = data_canvas.getContext("2d");
                data_ctx.drawImage(data_img_elt, 0, 0);
                img_data[batch_num] = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
                loaded[batch_num] = true;
                if (batch_num < test_batch) { loaded_train_batches.push(batch_num); }
                console.log('finished loading data batch ' + batch_num);
            };
            data_img_elt.src = "cifar10_batch_" + batch_num + ".png";
        }


        // ------------------------
        // END CIFAR10 SPECIFIC STUFF
        // ------------------------

        // loads a training image and trains on it with the network
        var paused = false;
        var load_and_step = function () {
            if (paused) return;

            var sample = sample_training_instance();
            step(sample); // process this image

        }

        var xLossWindow = new Array();
        var wLossWindow = new Array();
        var trainAccWindow = new Array();
        var valAccWindow = new Array();
        var testAccWindow = new Array();
        for (var i = 0; i< 5; i++) {
            xLossWindow[i] = new cnnutil.Window(100);
            wLossWindow[i] = new cnnutil.Window(100);
            trainAccWindow[i] = new cnnutil.Window(100);
            valAccWindow[i] = new cnnutil.Window(100);
            testAccWindow[i] = new cnnutil.Window(100);
        }

        var step = function (sample) {
            var x = sample.x;
            var y = sample.label;
            var stats = new Array();
            var lossx = new Array();
            var lossw = new Array();


            if (sample.isval) {
                var yhat = new Array();
                var val_acc = new Array();
                // use x to build our estimate of validation error
                for (var i = 0; net[i]; i++) {
                    net[i].forward(x);
                    yhat[i] = net[i].getPrediction();
                    val_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                    valAccWindow[i].add(val_acc[i]);
                }
                return;
            }

            // train on it with networks
            for (var i = 0; net[i]; i++) {
                stats[i] = trainer[i].train(x, y);
                lossx[i] = stats[i].cost_loss;
                lossw[i] = stats[i].l2_decay_loss;
                xLossWindow[i].add(lossx[i]);
                wLossWindow[i].add(lossw[i]);
            }

            // keep track of stats such as the average training error and loss
            var yhat = new Array();
            var train_acc = new Array();
            for (var i = 0; net[i]; i++) {
                yhat[i] = net[i].getPrediction();
                train_acc[i] = yhat[i] === y ? 1.0 : 0.0;
                trainAccWindow[i].add(train_acc[i]);
            }


            // visualize training status
            var train_elt = document.getElementById("trainstatus");
            train_elt.innerHTML = '';
            for (var i = 0; net[i]; i++) {
                var T = 'Forward time of network' + i + ' per example: ' + stats[i].fwd_time + 'ms';
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            for (var i = 0; net[i]; i++) {
                var T = 'Backprop time of network' + i + ' per example: ' + stats[i].bwd_time + 'ms';
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            for (var i = 0; net[i]; i++) {
                var T = 'Classification loss of network' + i + ' : ' + f2t(xLossWindow[i].get_average());
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            for (var i = 0; net[i]; i++) {
                var T = 'L2 Weight decay loss of network' + i + ' : ' + f2t(wLossWindow[i].get_average());
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            for (var i = 0; net[i]; i++) {
                var T = 'Training accuracy of network' + i + ' : ' + f2t(trainAccWindow[i].get_average());
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            for (var i = 0; net[i]; i++) {
                var T = 'Validation accuracy of network' + i + ' : ' + f2t(valAccWindow[i].get_average());
                train_elt.appendChild(document.createTextNode(T));
                train_elt.appendChild(document.createElement('br'));
            }
            var T = 'Examples seen: ' + step_num;
            train_elt.appendChild(document.createTextNode(T));
            train_elt.appendChild(document.createElement('br'));

            step_num++;
        }

        var reset_all = function () {
            // reinit trainer
            trainer = new Array();
            for (var i = 0; net[i]; i++) {
                trainer[i] = new convnetjs.SGDTrainer(net[i], { method: 'adadelta', batch_size: 4, l2_decay: 0.0001 });
            }

            // reinit windows that keep track of val/train accuracies
            for (var i = 0; i < t.length; i++) {
                xLossWindow[i].reset();
                wLossWindow[i].reset();
                trainAccWindow[i].reset();
                valAccWindow[i].reset();
                testAccWindow[i].reset();
            }

            step_num = 0;


        }

        var change_net = function () {
            layer_defs = [];
            net = [];
            for (var i = 0; i < 5; i++) {
                eval($("#newnet" + i).val());
            }
            reset_all();


            //I'm lazy now, so just paste the code above :(
            mother_defs = [];
            mother_defs.push({ type: 'input', out_sx: 32, out_sy: 32, out_depth: 3 });
            //loop for all positions but skip the input layer and softmax layer
            for (var i = 1; (i < layer_defs[0].length - 1) || (i < layer_defs[1].length - 1) || (i < layer_defs[2].length - 1) || (i < layer_defs[3].length - 1) || (i < layer_defs[4].length - 1); i += 2) {
                var temp_filterNum = 10000;//hope it's big enough
                //loop for each network
                for (var j = 0; net[j]; j++) {
                    if (layer_defs[j][i].type === 'conv' && layer_defs[j][i].filters < temp_filterNum && layer_defs[j][i].filters > 0) {
                        temp_filterNum = layer_defs[j][i].filters;
                    }
                }
                mother_defs.push({ type: 'conv', sx: 5, filters: temp_filterNum, stride: 1, pad: 2, activation: 'relu' });
                mother_defs.push({ type: 'pool', sx: 2, stride: 2 });//add a pooling layer after every conv layer by default
            }
            mother_defs.push({ type: 'softmax', num_classes: 10 });
            motherNet = new convnetjs.Net();
            motherNet.makeLayers(mother_defs);//implement it

            //for now, we show the motherNet by simply print each layer
            var m2t = document.getElementById("MotherNet_vis");
            m2t.innerHTML = '';
            for (var i = 0; mother_defs[i]; i++) {
                if (i == 0) {
                    var mt = 'Input layer:' + 'out_sx:' + mother_defs[0].out_sx + ' out_sy:' + mother_defs[0].out_sy + ' out_depth:' + mother_defs[0].out_depth;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'conv') {
                    var mt = 'Convolutional layer:' + ' sx:' + mother_defs[i].sx + ' filters:' + mother_defs[i].filters + ' stride:' + mother_defs[i].stride + ' pad:' + mother_defs[i].pad + ' activation:' + mother_defs[i].activation;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (mother_defs[i].type === 'pool') {
                    var mt = 'Pooling layer:' + ' sx:' + mother_defs[i].sx + ' stride:' + mother_defs[i].stride;
                    m2t.appendChild(document.createTextNode(mt));
                    m2t.appendChild(document.createElement('br'));
                }
                else if (i == mother_defs.length - 1) {
                    var mt = 'Softmax layer: number of classes: 10';//since we are using cifar10
                    m2t.appendChild(document.createTextNode(mt));
                }
            }


        }


    </script>
</head>


<body>

    <div id="wrap">

        <h1>Train Stats</h1>
        <div id="trainstatus"></div>

        <h1>Instantiate Networks and Trainers</h1>
        <div>
            <!--for now, we allow a user to specify up to 5 children networks-->
            <textarea id="newnet0" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet1" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet2" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet3" style="width:70%; height:200px;"></textarea>
            <br />
            <textarea id="newnet4" style="width:70%; height:200px;"></textarea>
            <br />
            <input id="buttonnn" type="submit" value="change network" onclick="change_net();" style="width:200px;height:30px;" />
        </div>

        <div>
            <h1>Generated MotherNet</h1>
            <div id="MotherNet_vis"></div>
        </div>

    </div>

</body>



</html>